## 3.データ型と変数宣言
本章では，Stanの式でのデータ型について説明します。Stanで使われる全ての変数は，データ型を宣言されていなければなりません。その型の値だけ，変数に割り当てることができます(変換データ`transformed data`と変換パラメータ`transformed parameter`の一時的な状態は除きます)。これはC++言語のようなプログラミング言語の利便性をフォローしたもので，Pythonのようなスクリプト言語や，RやBUGSのような統計言語の書き方とは異なります。

強くて静的な型つけ(typing)についてのモチベーションは，三つあります。

+ 強い型つけはプログラマーが変数に宣言をつける意思を持たせ，プログラムの理解を簡単にし，デバッグや補修をしやすくします。

+ 強い型つけは宣言に関わるプログラミングエラーを見つけにくくする(実行時)というよりむしろ，見つけやすくする(コンパイルの時に)のです。Stanのコンパイラ(CmdStan, RStanやPyStanなどのインターフェイスを通じて呼び出されるもの)はあらゆる型のエラーを見つけ出し，プログラムがコンパイルされる時に式の違反を素早く指し示します。

+ 制約つきの型は実行時のデータ，初期化，媒介する時の値にエラーがあれば，実行を許して広がったり潜在的に結果を汚したりするようなことが生じさせずに，できるだけ素早くそれをキャッチします。

強い型つけは，プログラムの違う場所で，あるいは違うところから呼び出されるプログラムにおいて，違う型のオブジェクトに同じ値を与えることを許しません。

### 3.1 データ型の概要

組み込み，あるいはユーザー定義関数の引数や，ローカル変数は基本的なデータ型である必要があり，制約のないプリミティブ型，ベクトル型，行列型あるいはそれらの配列であることになります。

Stanで関数に引数を渡すことは，基本型にアサインするのと同じように機能します。Stanの関数は，配列の字数も含めてその引数の基本型のみ指定しますが，大きさや定数については指定がありません。もちろん，関数はその振る舞いのあちこちで制約をチェックします。


#### プリミティブ型
Stanには連続値に対応した`real`と、整数に対応した`int`の2種のプリミティブ型が用意されています。


#### `vector`, `matrix`型
Stanには列ベクトルに対応した`vector`, 行ベクトルに対応した`row_vector`, 行列に対応した`matrix`の3種の行列ベースのデータ型が用意されています。

#### 配列
添え字をつけて宣言することで、任意の型（次節で紹介する制約付き型も含む）を配列とすることができます。以下に具体例を示します。

```
real x[10];
matrix[3,3] m[6,7];
```

上記のように記述すると、`ｘ`は1次元で10個の実数が含まれた値として宣言することになります。`m`は同様に、3 × 3行列を6 × 7個並べた2次元配列を宣言したことになります。

#### 制約付きデータ型

ローカル変数以外の変数を宣言する際には、制約をつけても構いません。制約は変数に対するデータ型だけはなく，`transformed data`，`transformed parameters`，`generated quantities`の各ブロック，および`parameters`ブロックにおける，制約されない空間から制約された空間への変換でもエラーチェックが行われます。

すべての基本データ型には，次のような構文を使って上限、下限を与えることができます。

```
int<lower=1> N;
real<upper=0> log_p;
vector<lower=-1,upper=1>[3,3] corr;
```

構造化されたベクトルや行列のための特別なデータ型もあります。ベクトルデータ型には四つの制約された型があります。`simplex`型は単体，`unit_vector`型は単位長ベクトル，`ordered`型はスカラーの大きさの順番に並べられたベクトル，そして`positive_ordered`型は正のスカラーの大きさ順に並べられたベクトルです。特別な行列データ型として，`corr_matrix`と`cov_matrix`があり，それぞれ相関行列(対称で正定値で対角項が1)，共分散行列(対称で正定値)です。`cholesky_factor_cov`型は，共分散行列のコレスキー因子(下三角で対角項が正，自身の転置行列との積が共分散行列になる)です。`cholesky_factor_corr`型は相関行列のコレスキー因子(下三角で対角項が正，行が単位長)です。

`data`,`transformed data`,`transformed parameters`,`generated quantities`ブロックで定義される変数に対して，制約についてのエラーチェックが行われます。`parameters`ブロックにおける変数宣言について，制約は決定的で，そこで制約された変数(宣言された制約)から制約されない変数(全ての$\mathbb{R}$の範囲)への変換が決定づけられます。

制約されたデータ型の最も重要な側面について，声を上げておくことには意味があるでしょう。

> モデルは制約の宣言に当たるまではあらゆるパラメータ値(ゼロでない密度，無限の対数密度に等しいものでも)をサポートしなければならない。

宣言された制約を満たすパラメータ値が制約を破っても，無限の対数密度を持っていないのであれば，サンプラーや最適化ではあらゆるおかしなパス，つまり行き詰まったり，初期化に失敗したり，行き過ぎたメトロポリスの棄却，分布の裾を探索することができないことによるバイアスのかかったサンプルなどの可能性を持っているかもしれないのです。

### 3.2プリミティブな数字のデータ型

残念ながら，整数や実数の数学的に美しい抽象化は，有限の精度しか持たないコンピュータの計算能力上，部分的にしかサポートできません。

#### 整数値

Stanは32ビット(4バイト)の整数を全ての整数表現に対して使います。整数値として表現できる最大値は$2^31-1$です。最小値は$-(2^31)$です。

整数からオーバーフローしたら，その数字は丸められます。つまりStanのプログラマーは自身で，この範囲内に整数値が収まるようにします。特に，全ての中間的な表現はこの範囲内の整数値でなければなりません。

整数の計算は足し算，引き算，掛け算のいずれも期待通りに動きますが，割り算の丸めに関してはそうではありません(節39.1により詳しい記述があります)。

#### 実数値

Stanは64ビット(8バイト)の浮動小数点で実数を扱います。StanはほぼIEEE754標準の浮動小数点計算を行います^[StanはC++上で整数を`int`として，実数を`double`としてコンパイルします。丸め誤差についての正確な詳細はコードを実行するコンパイラーとハードウェア・アーキテクチャに依存します。]。64ビットの数字の範囲はおおよそ$\pm 2^{1022}$で，$\pm 10^{307}$より少し大きいぐらいです。オーバーフローを起こさせないために，Stanモデルではこのような極端な値を取らないようにするほうがいいでしょう。

64ビット浮動小数点は，おおよそ小数点以下15桁の正確さです。が，演算をおこなうと，その結果では正確さがおちることがよくあります。ふたつのオペランドの間での正確さが異なると，演算結果が大きくなる場合があります。

三つの特別な値があります。(1)エラー状況における`not-a-number`値，(2)オーバーフローによる正の無限大，(3)オーバーフローによる負の無限大です。これらの特別な数字の振る舞いは，標準的IEEE754の振る舞いに従います。

##### Not-a-number

`Not-a-number`は伝播します。実数値関数の引数のひとつが `not-a-number` になれば，棄却（内部のC++では例外）となるか，あるいは，`not-a-number`そのものを返します。論理値の比較演算子について，一つの引数が`not-a-number`であれば，戻り値はゼロ(すなわち`false`)になります。

##### 無限の値

正の無限はそれ自身以外の全ての数字よりも大きな値で，`not-a-number`です。負の無限大も同じようにより小さな値です。無限大の値を有限の値に加えると，無限大を返します。有限の値を無限大で割ると0を返します。無限大を有限の値で割ると，符号は適切なままに無限大を返します。有限の値を0で割ると正の無限大になります。二つの無限大をを割り算すると，二つの無限の引き算として`not-a-number`を返します。無限大の値に敏感な関数がいくつかあります。例えば，指数関数は負の無限大が与えられれば0を返し，正の無限大が与えられれば正の無限大を返します。値が無限大になると勾配が破綻をきたすことがあり，最初にそうなると境界条件はあまり有用なものになりません。

#### 整数値から実数値への変換

Stanは必要であれば，自動的に整数値から実数値に引き上げますが，実数を整数に自動的に引き下げることはしません。これは非常に大きな整数値に対して，整数表現における浮動点計算の有効桁数がより小さいため，丸め誤差を引き起こします。

C++とは違って，実数値は決して整数値に引き下げられません。つまり，実数値は実数の変数にのみ割り当てられます。整数は整数の変数，実数の変数いずれにも割り当てられます。内部的には，整数表現は浮動点表現にcastされています。この操作にはオーバーヘッドが必ず伴うので，可能なら避けるべきです。

### 3.3 一変数データ型と変数宣言

Stanプログラムで使われる全ての変数は，明示的にデータ型を宣言しなければなりません。宣言の形式は，型と変数名からなります。このセクションでは一変数型で，次のセクションではベクトル，行列型，続くセクションで配列に言及します。

#### 制約のない整数型

制約のない整数は，`int`というキーワードを使って宣言されます。たとえば，変数`N`を整数として宣言する場合は次のようにします。

```
int N;
```

#### 制約のある整数型

整数のデータ型に上限，下限，あるいはその両方を与えることで，特定の区間の中でのみ値をとることが許されるような，制約を課すことができます。例えば，`N`を正の整数であるように宣言するには以下のようにします。

```
int<lower=1> N;
```

ここでは整数を含めた境界値を書きます。

整数の変数`cond`を二値すなわち1と0だけをとるように宣言するためには，上限と下限の境界値を与えて次のようにします。

```
int<lower=0,upper=1> cond;
```

#### 制約のない実数

制約のない実数は，`real`というキーワードを使って宣言します。以下の例では，`theta`を制約のない連続値として宣言しています。

```
real theta;
```

#### 制約付きの実数

実数値には整数の時と同じ文法で境界を与えることができます。理論的には(すなわち，代数的な正確さを持った計算上は)，実数値に対する境界は含めないものでしょう。残念ながら，有限の正確さしかない計算上では境界上の値についての丸めが生じるので，Stanではそれが許されてしまいます。

変数`sigma`を非負の数字に宣言するには次のようにします。
```
real<lower=0> sigma;
```

次の宣言では，変数`x`を-1以下の数字にします。

```
real<upper=-1> x;
```

変数`rho`を-1と1の間の値にするためには，以下の宣言をします。
```
real<lower=-1,upper=1> rho;
```

##### 無限の制約

下限を負の無限大にする，あるいは上限を正の無限大にしても無視されます。Stanは定数としての`positive_infinity()`と`negative_infinity()`を持っておりこの目的のために使えるかもしれませんが，無駄な書式として読み込みます。

#### 境界値の表現

整数や実数の変数に対する境界は，代数的な式でも構いません。必要なことは，その宣言の前位に定義されている変数だけを使っていること，これだけです。もし境界自身がパラメータであれば，舞台裏の変数変換のときに対数ヤコビアンの調整が行なわれます。

例えば，次のような宣言ができます。
```
data{
  real lb;
}
parameters{
  real<lower=lb> phi;
}
```
この宣言は，実数値パラメータ`phi`が実数値のデータ変数`lb`以上の値をとるということを意味しています。制約は複雑な式であってもいいのですが，整数の変数においては`int`型，実数の変数においては`real`型でなければなりません(ベクトル，行ベクトル，行列においても同じです)。制約を含む変数はその制約が使われるときに宣言されているあらゆる変数を使うことができます。例えば，

```
data{
  int<lower=1> N;
  real y[N];
}
parameters{
  real<lower=min(y),upper=max(y)> phi;
}
```
この宣言は，正の整数であるデータ変数`N`と，長さ`N`の実数値を持つデータ配列`y`を宣言し，それからパラメータの範囲を`y`の最小と最大の値の間にしています。この例のコードに示したように，関数`min()`と`max()`をこのような配列の要素に使うことができます。

### 3.4 ベクトル`vector`と行列`matrix`のデータ型

Stanは入れ物オブジェクトとして三つの型を用意しています。すなわち配列`array`，ベクトル`vector`，そして行列`matrix`です。ベクトルと行列は配列よりもデータ構造がより制約されたものです。ベクトルはもともと一次元の実数値を集めたものであるのにたいし，行列はもともと二次元です。ベクトル，行列，そして配列はお互いに割り当てあうことができません。その次元が同じであったとしても，です。Stanの中では，3×4行列と3×4配列は別ものです。

行列型を使いたいと思うときには，コードの中でその使用を宣言します。Stanではベクトルあるいは行列だけが使われる状況が，三つあります。

+ 行列計算をする(例えば行列の積)
+ 線形代数関数を使う(例えば固有値，行列式を求めるなど)
+ 多変数関数のパラメータや結果を使う(例えば多次元正規分布の引数として)

ベクトルと行列の型は整数値を返しません。これらは`real`型だけに制約されています^[Stanが複雑な整数行列の操作やブーリアン行列操作をするときは，変更されるかもしれません。整数は線形代数関数の入力値としては適切ではありません。]。

#### 1からのインデックス

ベクトルと行列は，配列もですが，Stanでは1からインデックスをつけます。これは統計では便利で，統計ソフトパッケージ，R,MATLAB,BUGSやJAGSで線形代数を実装するときと同じやり方だからです。一般的なコンピュータプログラム言語，例えばC++やPythonでは，配列のインデックスはゼロから始まります。

#### ベクトル

Stanにおけるベクトルは列ベクトルです。次のサブセクションで，行ベクトルについて解説します。ベクトルはサイズ(すなわち次元性)と一緒に宣言します。例えば，3次元ベクトルは`vector`というキーワードを使って次のように宣言します。

```
vector[3] u;
```

制約をつけてベクトルを宣言することもでき，次の例では要素3の非負の値を持つベクトルを宣言しています。

```
vector<lower=0>[3] u;
```

#### Unit Simplex型

単体`unit simplex`は非負の値を持ち要素の総和が1になるベクトルです。例えば，$(0.2,0.3,0.4,0.1)^{T}$はunit 4-simplexです。ユニットシンプレックスはカテゴリカル分布，あるいは多値名義分布のパラメータとして使われることが最も多く，デイィクレ分布から抽出された値として使われます。シンプレックスの宣言は，全体の次元性とともに行います。例えば，unit 5-simplexの`theta`を宣言するのは次のようにします。

```
simplex[5] theta;
```

ユニットシンプレックスはベクトルとして実装され，他のベクトルと同じように割り当てられます。シンプレックス変数は，他の制約付き変数のように，要素の神父レックス値が妥当かどうかを評価されます。シンプレックスについては，浮動小数点の不正確さに起因するエラーに対応する静的に指定された閾値，`\epsilon`の精度しか持ちません。

高次元の問題になると，シンプレックスは安定性を保つために推定アルゴリズムにおいてより小さなステップサイズを必要とします。これはサンプルのより高い受け入れ率と，より長いウォームアップ期間で達成されることで，最適化でより厳しいトレランスであればより多くの反復が必要ですし，パラメーターの初期値をばらさないようにしたり，いくつかのパラメータについてより情報を持った事前分布があればカスタムされた初期化をするなどの工夫が必要です。

#### 単位ベクトル型

単位ベクトル型(unit vector)はノルム1のベクトルです。例えば，$(0.5,0.5,0.5,0.5)^{T}$は要素4の単位ベクトルです。単位ベクトルは方向統計で使われることがります。単位ベクトルは全次元性を宣言しなければなりません。例えば，`theta`を要素5の単位ベクトルとして宣言するには，

```
unit_vector[5] theta;
```

のようにします。

単位ベクトルはベクトルとして実装され，他のベクトルに悪当てられたり，その逆になったりします。単位ベクトル変数は，他の制約付き変数のように，単位長が保持されていればいかようにも変化させることができます。すなわち，単位ベクトルは，浮動小数点の不正確さに起因するエラーに対応する静的に指定された閾値，`\epsilon`の精度しか持ちません。

#### 順序付きベクトル型

Stanにおける順序付きベクトル型(ordered vector)は，昇順に収められた要素を持つベクトルです。例えば，$(-1.3,2.7,2.71)^{T}$は要素3の順序付きベクトルです。順序付きベクトルは順序ロジスティック回帰モデル(セクション9.8をみてください)のカットポイントとして使われることが最も多いでしょう。

変数`c`を要素5の順序付きベクトルとして宣言するには，

```
orderd[5] c;
```

のようにします。

順序付きベクトルであることを宣言した後で，ユニットシンプレックス型のように，他のベクトルを割り当てたり，他のベクトルに割り当てられたりすることができます。制約が保たれているかどうかは，変数が宣言されたブロックが実行された後にチェックされます。

#### 正の順序付きベクトル型

正の順序付きベクトルは，順序付きベクトルと同じように操作しますが，全ての要素が正の数でなければなりません。例えば，$(2,3,7.4,12.9)$は正の，要素数4の順序付きベクトルです。

変数`d`が要素5の順序付きベクトルであると宣言するには，

```
positive_ordered[5] d;
```

のようにします。

順序付きベクトルのように，正の順序付きベクトルと宣言した後は，他のベクトルに割り当てたり，他のベクトルに割り当てられたりすることができます。制約は変数が宣言されたブロックが実行された後にチェックされます。

#### 行ベクトル

行ベクトルはキーワード`row_vector`を使って宣言されます。(列の)ベクトルのように，サイズとともに宣言します。例えば，1093次元の行ベクトル`u`は，

```
row_vector[1093] u;
```

のように宣言します。

ベクトルと同じように，次の例では要素10のベクトルの値が-1から1の間に入るように制約をかけています。

```
row_vector<lower=-1,upper=1>[10] u;
```

行ベクトルは列ベクトルに割り当てることはできませんし，列ベクトルも行ベクトルに割り当てることはできません。もし割り当てが必要であれば，転置の演算子を使って合わせることができます。

#### 行列

行列はキーワード`matrix`を使って，行と列の数とともに宣言します。たとえば，

```
matrix[3,3] A;
matrix[M,N] B;
```

は，行列Aが3 × 3で，行列Bが$M \times N$ 行列です。二つ目の宣言の仕方も形式はあっていて，変数$M$と$N$が整数として，行列の宣言の前に，`data`あるいは　`tramsformed data`ブロックで宣言されていなければなりません。

行列は制約をつけて宣言することもできて，(3 × 4)の行列が正でない値をとるのであれば，次のようにします。

```
matrix<upper=0>[3,4] B;
```

##### 行列の行に代入する

行列の行には，割り当て文の左側のインデックスを使って代入をすることができます。例えば，次のようにできます。

```
matrix[M,N] a;
row_vector[N] n;
// ...
a[1] = b;
```

これはベクトル`b`の値を行列`a`の第一行目，`a[1]`にコピーします。もし`a`の列数が`b`のサイズと同じでないならば，実行時エラーが返されます。`a`の行数は`N`で，`b`のサイズと同じです。

Stanでは値をコピーすることで割り当てを行います。これが意味するのは，`a[1]`に割り当てた後は`b`に何も影響しないし，そのあと`b`に割り当てても`a`に影響しないということです。

#### 相関行列

行列型は相関行列を表現するように制約をかけることができます。ある行列が相関行列だというのは，それが対称で正定値行列であることで，その要素が-1から1の間にあり，対角項は1であるということです。相関行列は正方行列なので，宣言に際して必要な数字は一次元だけです。例えば，

```
corr_matrix[3] Sigma;
```

とすることで，`Sigma`は3 × 3の相関行列になります。

相関行列は，次元が同じであれば，制約のない他の行列に割り当てることができますし，その逆もまた可能です。

#### 相関行列のコレスキー因子

行列型変数は相関行列のコレスキー因子で表現されるように制約をかけることができます。

相関行列のコレスキー因子$L$は$K \times K$の下三角行列で，対角要素が正で行の長さが1担っているものです(つまり，$\sum_{n=1}^K L_{m,n}^2 = 1$)。もし`L`が相関行列のコレスキー因子なら，$LL^T$は相関行列です(すなわち，対称で正定値行列で対角が単位です)。

宣言は以下のようにします。
```
cholesky_factor_corr[K] L;
```

これは`L`をK × Kの相関行列に対するコレスキー因子型にするものです。

#### 共分散行列

行列型変数は，共分散行列を表現するように制約をかけることができます。行列が共分散行列であるというのは，それが対称行列で正定値であることです。相関行列のように，共分散行列は宣言に際して，一次元だけ必要です。例えば，

```
corr_matrix[K] Omega;
```

とすることで`Omega`はK × Kの共分散行列であり，ここで`K`はデータ変数`K`の値です。

#### 共分散行列のコレスキー因子

行列型変数は共分散行列のコレスキー因子で表現されるように制約をかけることができます。これは時に便利で，また共分散行列を直接表現するよりも効率的であることがあります。

共分散行列のコレスキー因子$L$は$M \times N$の下三角行列($m<n$であればL[m.n]=0)で，対角要素は正(L[k,k]>0)，かつ$M \ge N$です。もし`L`がコレスキー因子であれば，$\Sigma = LL^T$は共分散行列です。さらに，全ての共分散行列はコレスキー因子化できます。

コレスキー因子の典型的な使い方としては，普通一つの次元性をつかって宣言する

```
cholesky_factor_cov[4] L;
```

とするものですが，二次元を使って上と同じ表現をすると`cholesky_factor_cov[4,4]`となります。この`cholesky_factor_cov[M,N]`とするやり方は，一般的な$M \times N$行列に使われます。

#### 制約された変数に割り当てる

あらゆる型の制約された変数には，他の変数で，型は同じで制約されていないものから値を割り当てられるかもしれませんし，その逆もまたあり得ます。同じ基本型であること，配列の次元数は同じであることは，厳密にチェックしてマッチングされます。制約は考慮されませんが，基本的なデータ型だけは合わせなければなりません。例えば，変数が`real<lower=0,upper=1>`で宣言されていれば，これを`real`で宣言されている変数に割り当てたり，その逆をしたりすることができます。同様に，変数が`matrix[3,3]`で宣言されていれば，これを`cov_matrix[3]`で宣言された変数や`cholesky_factor_cov[3]`で宣言された変数に割り当てることも，その逆もできます。

それぞれの文の関わるブロックが終わりに到達した時に，制約が守られているかどうかのチェックが行われます。これは実行時サイズチェックも含みます。Stanコンパイラは一次元の行列を次数の合わない行列に割り当て用としている時には，その問題を把握できません。

#### サイズの宣言としての式

サイズを式で表現した変数を宣言することができます。こうした式にはデータあるいは変換されたデータ変数のみ含めることができます。全てのサイズは，データが読み込まれ，データ変換変数がその文によって定義された時にだけ，決定づけられることを保証しています。例えば，次のようなやり方はあっています。

```
data{
  int<lower=0> N_observed; int<lower=0> N_missing;
  // ...

transformed parameters{
  vector[N_observed+N_missing] y;
  /// ...
```

#### ベクトルや行列の要素に割り当てる

`v`が列ベクトル，あるいは行ベクトルであれば，`v[2]`がベクトルの第二番目の要素になります。また`m`が行列であれば，`m[2,3]`は二行三列目の要素の値です。

行列に一つの引数だけ与えると，その行が返ってきます。例えば，もし`m`が行列であれば，`m[2]`は二行目を意味します。これはStanブロックで次のように表現することを可能にします。

```
matrix[M,N] m;
row_vector[N] v;
real x;
/// ...
v = m[2];
x = v[3];   // x == m[2][3] == m[2,3]
```

`m[2]`の型は行ベクトルですから，`m`の二番目の行になります。つまり，`m[2][3]`と書く代わりに，`m[2,3]`とすることで，二番目の行の三番目の要素にアクセスします。選択できるのであれば，`m[2,3]`の形式で書いたほうがいいでしょう^[Stanのバージョン1.0では，`m[2,3]`の書き方がより効果的でした。というのも，このやり方は何かを作り出すわけではないですし，一時的に`m[2]`という中間式を使うわけではないからです。のちのバージョンで，Stanコンパイラが別れたセル，`m[2][3]`も`m[2,3]`と同じように効率化するようになりました]。

#### サイズ宣言の制限

整数の式を使って，ベクトル，行列，配列のサイズを指定することができます。例えば，$M+N$サイズのベクトルを次のように宣言できます。

```
vector[M+N] y;
```

整数を示すあらゆる式はサイズ宣言に使えますが，全ての変数がデータ，データ変換，あるいはローカル変数として含まれていなければなりません。つまり，サイズ宣言に使う式には，パラメータや変換されたパラメータ，生成量を使うことはできません。


### 3.5 配列データ型

Stanは任意の次元数の配列をサポートしています。配列型に入る数字はどの型でもよく，配列は単純な実数や整数でもいいし，ベクトル，行列，他の配列であっても構いません。配列は一連の整数を保持する唯一の方法で，Stanの関数のなかには，離散分布のように，整数の引数を必要とするものがあります。

二次元配列は配列の配列に過ぎずません。概念的にも，具体的な実装上もです。インデックスが配列に与えられたとき，そのインデックス番号に該当する数字が返されます。一つ以上のインデックスが渡されたときは，インデックスの操作が次々に繋がります。例えば，もし`a`が二次元配列だとすると，`a[m,n]`は`a[m][n]`の簡略化表記になります。ベクトル，行列，配列は，たとえ次元数が同じであったとしても互いに代入することはできません。

#### 配列変数を宣言する

配列は変数名の後に四角いカッコで次元数を含めることで宣言します。

変数`n`が5つの整数を持つ配列だと宣言するのは次のようにします。

```
int n[5];
```

実数値の二次元配列で，3行4列のものは，次のように宣言します。

```
real a[3,4];
```

三次元配列`z`が，5行，4列，2段組の正の実数だとすると，次のように宣言します。

```
real<lower=0> z[5,4,2];
```

配列はベクトルを要素に持つことができます。例えば，

```
vector[7] mu[3];
```

とすると，`mu`はサイズ3の配列で，そこには7つの要素のあるベクトルを詰め込んだことになります。配列は行列を要素に持つこともできます。次の例，

```
matrix[7,2] mu[15,12]
```

は，$15 \times 12$の配列が $7\times 2$ 個あることになります。制約付きの型を配列に使うこともでき，次のように宣言すると，

```
cholesky_factor_cov[5,6] mu[2,3,4];
```

これは$2 \times 3 \times 4$の配列が共分散行列のコレスキー因子$5 \times 6$を持っていることになります。

#### 配列の要素や下位の配列へのアクセス

もし`x`が長さ5の1次元配列だとすると，`x[1]`は配列の最初の要素になるし，`x[5]`は最後の要素になります。$3 \times 4$の二次元配列`y`では，`y[1,1]`は最初の要素で`y[3,4]`が最後の要素です。三次元配列`z`だと，最初の要素は`z[1,1,1]`，以下同様，となります。

配列の下位配列にアクセスするには，全体よりも少ないインデックスを与えてやることです。例えば，`y`を3行4列の二次元配列だとしましょう。ここで`y[3]`は長さ4の一次元配列を返します。これが意味するのは，`y`の三番目の行の最初の列の値にアクセスするのに，`y[3][1]`を`y[3,1]`の代わりに使えるということです。`y[3,1]`の形式の方が，より好ましい形ではあります(この章の脚注3を見てください)。

#### 割り当て

下位の配列は他の変数のように操作したり割り当てたりすることができます。行列の振る舞いと似ていて，Stanは次のようなブロックを許します。

```
real w[9,10,11];
real x[10,11];
real y[11];
real z;
// ...
x = w[5];
y = x[4]; // y == w[5][4] == w[5,4]
z = y[3]; // z == w[5][4][3] == w[5,4,3]
```

#### 行列とベクトルの配列

ベクトルと行列の配列は，二重になった配列と同じようにアクセスすることができます。以下のベクトルとスカラーの宣言例を見てみましょう。

```
vector[5] a[3,4];
vector[5] b[4];
vector[5] c;
real x;
```

これらの宣言を使って，次のような割り当てをすることができます。

```
b = a[1];     // 結果はベクトルの配列です
c = a[1,3];   // 結果はベクトルです
c = b[3];     // 上と同じ結果になります
x = a[1,3,5]; // 結果はスカラーです
x = b[3,5];   // 上と同じ結果になります
x = c[5];     // 上と同じ結果になります
```

行ベクトルとその他のベクトル型の変数(simplex型とordered型)は，同じやり方でインデックスを使うことができます。

次の行列，ベクトル，スカラーの宣言を考えて見ましょう。

```
matrix[6,5] d[3,4];
matrix[6,5] e[4];
matrix[6,5] f;
row_vector[5] g;
real x;
```

これらの宣言を使って，次のように定義することができます。

```
e = d[1];       // 結果は行列の配列です
f = d[1,3];     // 結果は行列です
f = e[3];       // 上と同じ結果になります
g = d[1,3,2];   // 結果は行ベクトルです
g = e[3,2];     // 上と同じ結果になります
g = f[2];       // 上と同じ結果になります
x = d[1,3,5,2]; // 結果はスカラーです
x = e[3,5,2];   // 上と同じ結果になります
x = f[5,2];     // 上と同じ結果になります
x = g[2];       // 上と同じ結果になります
```

ここで示したように，`f[2]`の結果は一つのインデックスを行列に与えたことになり，それが行を示すので，ここでは行列`f`の2列目がかえってきます。

#### 配列に対する部分割り当て

配列の下位配列は割り当て分の左片側にインデックスを与えることでできます。例えば，次のようなやり方ができます。

```
real x[I,J,K];
real y[J,K];
real z[K];
//...
x[1] = y;
x[1,1] = z;
```

サイズは合っていなければなりません。ここでは`x[1]`が$J \times K$の配列で,`Y`も同じです。

部分的な配列の割り当ては，行列，ベクトル，行ベクトルの配列についても同様の動きをします。

#### 配列，ベクトル，行列の型の混在

配列，行ベクトル，列ベクトル，そして行列はStanでは相互に交換できません。ですから，これらの基本的な型のどの変数も，他の型のものに割り当てることができません。他の型が必要とされている引数にも使えません(引数としての使用も代入のルールに従います)。

##### ベクトルと配列を混ぜる

例えば，ベクトルは配列を割り当てることはできませんし，逆もまた然りです。

```
real a[4];
vector[4] b;
row_vector c[4];
// ...
a = b; // ベクトルを配列に，間違った割り当てをしています
b = a; // 配列をベクトルに，間違った割り当てをしています
a = c; // 行ベクトルを配列に，間違った割り当てをしています
c = a; // 配列を行ベクトルに，間違った割り当てをしています
```

##### 行と列のベクトルを混ぜる

行ベクトルを列ベクトルに割り当てる，あるいはその逆も適切な用法ではありません。

```
vector b[4];
row_vector c[4];
// ...
b = c; // 行ベクトルを列ベクトルに，間違った割り当てをしています
c = b; // 列ベクトルを行ベクトルに，間違った割り当てをしています。
```

##### 行列と配列を混ぜる

行列にも同じことが言えます。2次元配列は行列に割り当てることはできませんし，逆もまた然りです。

```
real a[3,4];
matrix[3,4] b;
// ...
a = b; // 行列を配列に，間違った割り当てをしています
b = a; // 配列を行列に，間違った割り当てをしています
```

##### 行列とベクトルを混ぜる

$1 \times N$の行列を行ベクトルに割り当てることもできません。逆もまた然りです。

```
matrix[1,4] a;
row_vector[4] b;
// ...
a = b; // 行ベクトルを行列に，間違った割り当てをしています
b = a; // 行列を行ベクトルに，間違った割り当てをしています
```

同様に，$M \times 1$の行列を列ベクトルに割り当てることもできません。

```
matrix[4,1] a;
vector[4] b;
// ...
a = b; // 列ベクトルを行列に，間違った割り当てをしています
b = a; // 行列を列ベクトルに，まtがった割り当てをしています
```

#### サイズ宣言の制約

配列のサイズを指定するのに使われるのは整数です。同じ制約が，ベクトルや行列のサイズを指定する時にも適用されます。サイズの宣言は整数そのものでなければならず，パラメータや変換されたパラメータ，生成量を含んでいてはいけません。


#### サイズゼロの配列

ある配列の次元サイズがゼロであれば，配列全体のサイズがゼロになります。つまり，もし次のように宣言したとすると

```
real a[3,0];
```

この`a`のサイズは結果的にゼロになりますので，実行時のあらゆる次元に対する要求の結果がゼロになります。上の宣言を`a[1]`にすれば，サイズゼロの一次元配列になります。比較として，次のような宣言

```
real b[0,3];
```

をみてみましょう，これも全体のサイズがゼロの配列を生むことになりますが，この場合は，`b`に適切なインデックスを入れる方法が全くありません。なぜなら`b[0]`は定義されないからです。この配列は，実行時には$0 \times 0$配列のように振る舞います。例えば，`to_matrix(b)`は$0\times 0$行列になり，$0 \times 3$の行列にはなりません。

### 3.6. 変数の型　vs. 制約とサイズ

変数についている型の情報は，変数の型と次元性だけを含んでいます。

#### 型情報はサイズの情報を持っていない

ある変数に与えられたサイズは，データ型の一部ではありません。例えば，変数を次のように宣言したとします。

```
real a[3];
```

これは変数を配列として宣言しています。宣言によってサイズ3を持ったという事実は，宣言の一部ではありますが，その背後にある型の情報の一部ではありません。

##### サイズはいつチェックされる？

サイズは動的に(実行時に)決定するため，プログラムがコンパイルされるときの静的な型チェックはできません。結果的に，サイズの不一致によるエラーは実行時エラーとして発生します。例えば，サイズ5の配列をサイズ6の配列に割り当てようとすると，実行時エラーになります。同様に，$N \times M$に$J \times K$行列をかけようとする操作は，$M \neq J$であれば実行時エラーになります。

#### 型情報は制約の情報を持っていない

サイズと同様，Stanでは制約も変数の型の一部のように扱うことはありませんので，コンパイル時の操作チェックに入ってくることはありません。Stanが行列を引数として受け取るときはいつでも，文法的には相関行列でも，共分散行列でも，コレスキー因子でも受け付けます。ですから，共分散行列を行列に割り当てられるかもしれないし，その逆があるかもしれません。

同様に，丸められた実数が制約のない実数に割り当てられる，あるいはその逆もあり得ます。

##### 関数の引数についての制約はいつチェックされる？

関数が呼び出されるときに，その引数の制約はチェックされることもありますが，必ずというわけではありません。C++の標準ライブラリ関数については例外です。あらゆる確率関数，累積分布関数は，その関数が呼び出される実行時に引数が適切であるかどうかをチェックします。

##### 宣言された変数の中身はいつチェックされる？

データ変数にとって，要素がチェックされるのは変数がデータファイルかそのほかのソースから呼ばれた後になります。変換されたデータ変数については，`transformed data`ブロックの文が実行された後にチェックされます。ですから，変数の中間値が宣言された要素の条件を満たしていないことはルールにあっています。

パラメータについては，要素は変換が適用されたときにenforceされるので，チェックされる必要がありません。変換されたパラメータについては，チェックは`transformed parameters`ブロックの文が実行された後にチェックされます。

変数を定義する全てのブロック(`transformed data`,`transformed parameters`,`generated quantities`)において，実数値は`NaN`として初期化され，整数値はあり得る最も小さい整数値として初期化されます(すなわち，大きな絶対値を持つ負の数)。

生成量としては，制約は`generated quantities`ブロックでの文が実行された後にenforceされます。

### 型名記法

データ型を参照するために，その参照方法を用意しておくと便利ですね。このセクションにおいて説明する型名記法は，Stanプログラミング言語の一部を構成するものではなく，型の簡単な記述を可能にするためのものです。

サイズの情報はデータ型の情報の一部ではないので，データ型はサイズ情報がないまま記述されることがあります。例えば，`real[]`は一次元配列の実数型で，`matrix`は行列の型です。三次元整数配列型は，`int[　,　,　]`と書くことができますが，これはインデックスをつけるためのスロットの数を示しています。同様に，`vector[ , ]`はベクトルの二次元配列型です。

## 3.7 変数宣言と定義を合成する

Stanは変数への値の割り当てを，一つの文の中で宣言，定義することができます。割り当て可能な変数は，

+ ローカル変数
+ `transformed data`,`transformed parameters`,`generated quantities`ブロックで宣言された変数

です。例えば，文として

```
int N = 5;
```

とすると，変数`N`は整数のスカラー型だと宣言すると同時に，これに式として5の値であるとするものです。

### 割り当てる型

代入の右辺にある式の型は，変数の型が宣言された時に代入可能でなければなりません。例えば，次のようにすることは可能です。

```
real sum = 0;
```

`0`は`int`型で`sum`は`real`型ですが，整数型のスカラーは実数型のスカラー変数に割り当て可能ですのでこの方法は許されます。他のどの場合でも，割り当てる右辺にある式の型は，変数の型と同じでなければなりません。

どのような型でも割り当てられます。例えば，

```
matrix[3,2]a = b;
```

は，ある行列変数`a`を宣言し，それに`b`の値を割り当てます。この`b`は，複合宣言文の形式に適合した行列型でなければなりません。行列のサイズは静的宣言の要素ではないので，実行時までチェックされません。

### 右辺の式による表現

右辺側は，宣言する変数に割り当てられる型であればどのような式でも構いません。例えば，

```
matrix[3,2] a = 0.5 * (b + c);
```

とすれば，行列変数`a`は`b+c`の和の半分が割り当てられます。`b`と`c`に求められているのは，式`b+c`が`matrix`型になっているということだけです。例えば，`b`は行列型で，`c`が実数型であるということができます。なぜなら，スカラーに行列を加算すると行列型ができ，それにスカラーをかけることでもう一つの行列型になるからです。

右辺の式で，ユーザー定義関数を呼び出すことが可能で，単純な式(例えば反復や再帰的なアルゴリズムで書き換えられない一般的なアルゴリズムでも構いません。

### 式の中のスコープ

複合宣言や定義の中のブロックで使うことができる関数や，スコープの中にあるあらゆる変数は，複合宣言，定義文の右辺の式で用いられるかもしれません。

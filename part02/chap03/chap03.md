## 3.データ型と変数宣言
本章では，Stanの式でのデータ型について説明します。Stnで使われる全ての変数は，データ型を宣言されていなければなりません。その型の値だけ，変数に割り当てることができます(変数変換`transformed data`とパラメータ変換`transformed parameter`の一時的な状態は除きます)。これはC++言語のようなプログラミング言語の利便性をフォローしたもので，Pythonのようなスクリプト言語や，RやBUGSのような統計言語の書き方とは異なります。

強くて静的な型つけ(typing)についてのモチベーションは，三つあります。

+ 強い型つけはプログラマーが変数に宣言をつける意思を持たせ，プログラムの理解を簡単にし，デバッグや補修をしやすくします。

+ 強い型つけは宣言に関わるプログラミングエラーを見つけにくくする(実行時)というよりむしろ，見つけやすくする(コンパイルの時に)のです。Stanのコンパイラ(CmdStan, RStanやPyStanなどのインターフェイスを通じて呼び出されるもの)はあらゆる型のエラーを見つけ出し，プログラムがコンパイルされる時に式の違反を素早く指し示します。

+ 制約つきの型は実行時のデータ，初期化，媒介する時の値にエラーがあれば，実行を許して広がったり潜在的に結果を汚したりするようなことが生じさせずに，できるだけ素早くそれをキャッチします。

強い型つけは，プログラムの違う場所で，あるいは違うところから呼び出されるプログラムにおいて，違う型のオブジェクトに同じ値を与えることを許しません。

### 3.1 データ型の概要

組み込み，あるいはユーザー定義関数の引数や，ローカル変数は基本的なデータ型である必要があり，制約のないプリミティブ型，ベクトル型，行列型あるいはそれらの配列であることになります。

Stanで関数に引数を渡すことは，基本型にアサインするのと同じように機能します。Stanの関数は，配列の字数も含めてその引数の基本型のみ指定しますが，大きさや定数については指定がありません。もちろん，関数はその振る舞いのあちこちで制約をチェックします。


#### プリミティブ型
Stanには連続値に対応した`real`と、整数に対応した`int`の2種のプリミティブ型が用意されています。


#### `vector`, `matrix`型
Stanには列ベクトルに対応した`vector`, 行ベクトルに対応した`row_vector`, 行列に対応した`matrix`の3種の行列ベースのデータ型が用意されています。

#### 配列
添え字をつけて宣言することで、任意の型（次節で紹介する制約付き型も含む）を配列とすることができます。以下に具体例を示します。

```
real x[10];
matrix[3,3] m[6,7];
```

上記のように記述すると、`ｘ`は1次元で10個の実数が含まれた値として宣言することになります。`m`は同様に、3 × 3行列を6 × 7個並べた2次元配列を宣言したことになります。

#### 制約付きデータ型

ローカル変数以外の変数を宣言する際には、制約をつけても構いません。制約は変数に対するデータ型だけはなく，変数変換，パラメータ変換，生成量ブロック，パラメータブロックにおける制約されない空間から制約された空間への変換でもエラーチェックが行われます。

すべての基本データ型には，次のような構文を使って上限、下限を与えることができます。

```
int<lower=1> N;
real<upper=0> log_p;
vector<lower=-1,upper=1>[3,3] corr;
```

構造化されたベクトルや行列のための特別なデータ型もあります。ベクトルデータ型には四つの制約された型があります。`simplex`型は単一神父レックス，`unit_vector`型は単位長ベクトル，`ordered`型はスカラーの大きさの順番に並べられたベクトル，そして`positive_ordered`型は正のスカラーの大きさ順に並べられたベクトルです。特別な行列データ型として，`corr_matrix`と`cov_matrix`があり，それぞれ相関行列(対称で正定値で対角項が1)，共分散行列(対称で正定値)です。`cholesky_factor_cov`型は，共分散行列のコレスキー因子(下三角で対角項が正，自身の転置行列との積が共分散行列になる)です。`cholesky_factor_corr`型は相関行列のコレスキー因子(下三角で対角項が正，行が単位長)です。

`data`,`transformed data`,`transformed parameters`,`generated quantities`ブロックで定義される変数に対して，制約についてのエラーチェックが行われます。`parameters`ブロックにおける変数宣言について，制約は決定的で，そこで制約された変数(宣言された制約)から制約されない変数(全ての$\mathbb{R}$の範囲)への変換が決定づけられます。

制約されたデータ型の最も重要な側面について，声を上げておくことには意味があるでしょう。

> モデルは制約の宣言に当たるまではあらゆるパラメータ値(ゼロでない密度，無限の対数密度に等しいものでも)をサポートしなければならない。

宣言された制約を満たすパラメータ値が制約を破っても，無限の対数密度を持っていないのであれば，サンプラーや最適化ではあらゆるおかしなパス，つまり行き詰まったり，初期化に失敗したり，行き過ぎたメトロポリスの棄却，分布の裾を探索することができないことによるバイアスのかかったサンプルなどの可能性を持っているかもしれないのです。

### 3.2プリミティブな数字のデータ型

残念ながら，整数や実数の数学的に美しい抽象化は，有限の精度しか持たないコンピュータの計算能力上，部分的にしかサポートできません。

#### 整数値

Stanは32ビット(4バイト)の整数を全ての整数表現に対して使います。整数値として表現できる最大値は$2^31-1$です。最小値は$-(2^31)$です。

整数からオーバーフローしたら，その数字は丸められます。つまりStanプログラマー次第でこの範囲内に整数値が収まるようにします。特に，全ての中間的な表現はこの範囲内の整数値でなければなりません。

整数の計算は足し算，引き算，掛け算のいずれも期待通りに動きますが，割り算の丸めに関してはそうではありません(節39.1により詳しい記述があります)。

#### 実数値

Stanは64ビット(8バイト)の浮動小数点で実数を扱います。StanはほぼIEEE754標準の浮動小数点計算を行います^[StanはC++上で整数を`int`として，実数を`double`としてコンパイルします。丸め誤差についての正確な詳細はコードを実行するコンパイラーとハードウェア・アーキテクチャに依存します。]。64ビットの数字の範囲はおおよそ$\pm 2^{1022}$で，$\pm 10^{307}$より少し大きいぐらいです。オーバーフローを起こさせないために，Stanモデルではこのような極端な値を取らないようにするほうがいいでしょう。

64ビット浮動小数点は，おおよそ小数点以下15桁の正確さです。が，つなぎ合わせた時に，この正確さは少し損なわれます。そのような場合，二つの操作の間の正確さが異なり，結果が少し大きくなります。

三つの特別な値があります。(1)エラー状況における`not-a-number`値，(2)オーバーフローによる正の無限大，(3)オーバーフローによる負の無限大です。これらの特別な数字の振る舞いは，標準的IEEE754の振る舞いに従います。

#### Not-a-number

`Not-a-number`は増殖します。もし引数が実数値の関数が`not-a-number`になれば，(C++における例外を除いて)棄却され，`not-a-number`そのものを返します。二値の比較演算子について，一つの引数が`not-a-number`であれば，戻り値はゼロ(すなわち`false`)になります。

#### 無限の値

正の無限はそれ自身以外の全ての数字よりも大きな値で，`not-a-number`です。負の無限大も同じようにより小さな値です。無限大の値を有限の値に加えると，無限大を返します。有限の値を無限大で割ると0を返します。無限大を有限の値で割ると，符号は適切なままに無限大を返します。有限の値を0で割ると正の無限大になります。二つの無限大をを割り算すると，二つの無限の引き算として`not-a-number`を返します。無限大の値に敏感な関数がいくつかあります。例えば，指数関数は負の無限大が与えられれば0を返し，正の無限大が与えられれば正の無限大を返します。値が無限大になると勾配が破綻をきたすことがあり，最初にそうなると境界条件はあまり有用なものになりません。

### 整数値から実数値への変換

Stanは必要であれば，自動的に整数値から実数値に引き上げますが，実数を整数に自動的に引き下げることはしません。これは非常に大きな整数値に対して，整数表現における浮動点計算の有効桁数がより小さいため，丸め誤差を引き起こします。

C++とは違って，実数値は決して整数値に引き下げられません。つまり，実数値は実数の変数にのみ割り当てられます。整数は整数の変数，実数の変数いずれにも割り当てられます。内部的には，整数表現は浮動点表現にcastされています。この操作は間接的に行われないので，可能なら避けるべきです。

### 3.3 一変数データ型と変数宣言

Stanプログラムで使われる全ての変数は，明示的にデータ型を宣言しなければなりません。宣言の形式は，型と変数名からなります。このセクションでは一変数型で，次のセクションではベクトル，行列型，続くセクションで配列に言及します。

#### 制約のない整数型

制約のない整数は，`int`というキーワードを使って宣言されます。たとえば，変数`N`を整数として宣言する場合は次のようにします。

```
int N;
```

#### 制約のある整数型

整数のデータ型に上限，下限，あるいはその両方を与えることで，特定の区間の中でのみ値をとることが許されるような，制約を課すことができます。例えば，`N`を正の整数であるように宣言するには以下のようにします。

```
int<lower=1> N;
```

ここでは整数を含めた境界値を書きます。

整数の変数`cond`を二値すなわち1と0だけをとるように宣言するためには，上限と下限の境界値を与えて次のようにします。

```
int<lower=0,upper=1> cond;
```

#### 制約のない実数

制約のない実数は，`real`というキーワードを使って宣言します。以下の例では，`theta`を制約のない連続値として宣言しています。

```
real theta;
```

#### 制約付きの実数

実数値には整数の時と同じ文法で境界を与えることができます。理論的には(すなわち，代数的な正確さを持った計算上は)，実数値に対する境界は含めないものでしょう。残念ながら，有限の正確さしかない計算上では境界上の値についての丸めが生じるので，Stanではそれが許されてしまいます。

変数`sigma`を非負の数字に宣言するには次のようにします。
```
real<lower=0> sigma;
```

次の宣言では，変数`x`を-1以下の数字にします。

```
real<upper=-1> x;
```

変数`rho`を-1と1の間の値にするためには，以下の宣言をします。
```
real<lower=-1,upper=1> rho;
```

##### 無限の制約

下限を負の無限大にする，あるいは上限を正の無限大にしても無視されます。Stanは定数としての`positive_infinity()`と`negative_infinity()`を持っておりこの目的のために使えるかもしれませんが，無駄な書式として読み込みます。

#### 境界値の表現

整数や実数の変数に対する境界は，代数的な式でも構いません。必要なことは，その宣言の前位に定義されている変数だけを使っていること，これだけです。もし境界自身がパラメータであれば，舞台裏の変数変換で対数ヤコビアンをつかって説明します。

例えば，次のような宣言ができます。
```
data{
  real lb;
}
parameters{
  real<lower=lb> phi;
}
```
この宣言は，実数値パラメータ`phi`が実数値のデータ変数`lb`以上の値をとるということを意味しています。制約は複雑な式であってもいいのですが，整数の変数においては`int`型，実数の変数においては`real`型でなければなりません(ベクトル，行ベクトル，行列においても同じです)。制約を含む変数はその制約が使われるときに宣言されているあらゆる変数を使うことができます。例えば，

```
data{
  int<lower=1> N;
  real y[N];
}
parameters{
  real<lower=min(y),upper=max(y)> phi;
}
```
この宣言は，正の整数であるデータ変数`N`と，長さ`N`の実数値を持つデータ配列`y`を宣言し，それからパラメータの範囲を`y`の最小と最大の値の間にしています。この例のコードに示したように，関数`min()`と`max()`をこのような配列の要素に使うことができます。

### 3.4 ベクトル`vector`と行列`matrix`のデータ型

Stanは入れ物オブジェクトとして三つの型を用意しています。すなわち配列`array`，ベクトル`vector`，そして行列`matrix`です。ベクトルと行列は配列よりもデータ構造がより制約されたものです。ベクトルはもともと一次元の実数値を集めたものであるのにたいし，行列はもともと二次元です。ベクトル，行列，そして配列はお互いに割り当て会うことができません。その次元が同じであったとしても，です。Stanの中では，3×4行列と3×4配列は別ものです。

行列型を使いたいと思うときには，コードの中でその仕様を宣言します。Stanではベクトルあるいは行列だけが使われる状況が，三つあります。

+ 行列計算をする(例えば行列の積)
+ 線形代数関数を使う(例えば固有値，行列式を求めるなど)
+ 多変数関数のパラメータや結果を使う(例えば多次元正規分布の引数として)

ベクトルと行列の型は整数値を返しません。これらは`real`型だけに制約されています^[Stanが複雑な整数行列の操作やブーリアン行列操作をするときは，変更されるかもしれません。整数は線形代数関数の入力値としては適切ではありません。]。

#### 1からのインデックス

ベクトルと行列は，配列もですが，Stanでは1からインデックスをつけます。これは統計では便利で，統計ソフトパッケージ，R,MATLAB.BUGSやJAGSで線形代数を実装するときと同じやり方だからです。一般的なコンピュータプログラム言語，例えばC++やPythonでは，配列のインデックスはゼロから始まります。

#### ベクトル

Stanにおけるベクトルは列ベクトルです。次のサブセクションで，行ベクトルについて解説します。ベクトルはサイズ(すなわち次元性)と一緒に宣言します。例えば，3次元ベクトルは`vector`というキーワードを使って次のように宣言します。

```
vector[3] u;
```

制約をつけてベクトルを宣言することもでき，次の例では要素3の非負の値を持つベクトルを宣言しています。

```
vector<lower=0>[3] u;
```

#### Unit Simplex型

ユニットシンプレックス`unit simplex`は非負の値を持ち要素の総和が1になるベクトルです。例えば，$(0.2,0.3,0.4,0.1)^{T}$はunit 4-simplexです。ユニットシンプレックスはカテゴリカル分布，あるいは多値名義分布のパラメータとして使われることが最も多く，デイィクレブンプから抽出された値として使われます。シンプレックスの宣言は，全体の次元性とともに行います。例えば，unit 5-simplexの`theta`を宣言するのは次のようにします。

```
simplex[5] theta;
```

ユニットシンプレックスはベクトルとして実装され，他のベクトルと同じように割り当てられます。シンプレックス変数は，他の制約付き変数のように，要素の神父レックス値が妥当かどうかを評価されます。シンプレックスについては，浮動小数点の不正確さに起因するエラーに対応する静的に指定された閾値，`\epsilon`の精度しか持ちません。

高次元の問題になると，シンプレックスは安定性を保つために推定アルゴリズムにおいてより小さなステップサイズを必要とします。これはサンプルのより高い受け入れ率と，より長いウォームアップ期間で達成されることで，最適化でより厳しいトレランスであればより多くの反復が必要ですし，初期値をバラバラにしたり，いくつかのパラメータについてより情報を持った事前分布があればカスタムされた初期化をするなどの工夫が必要です。

#### 単位ベクトル型

単位ベクトル型(unit vector)はノルム1のベクトルです。例えば，$(0.5,0.5,0.5,0.5)^{T}$は要素4の単位ベクトルです。単位ベクトルは方向統計で使われることがります。単位ベクトルは全次元性を宣言しなければなりません。例えば，`theta`を要素5の単位ベクトルとして宣言するには，

```
unit_vector[5] theta;
```

のようにします。

単位ベクトルはベクトルとして実装され，他のベクトルに悪当てられたり，その逆になったりします。単位ベクトル変数は，他の制約付き変数のように，単位長が保持されていればいかようにも変化させることができます。すなわち，単位ベクトルは，浮動小数点の不正確さに起因するエラーに対応する静的に指定された閾値，`\epsilon`の精度しか持ちません。

#### 順序付きベクトル型

Stanにおける順序付きベクトル型(ordered vector)は，昇順に収められた要素を持つベクトルです。例えば，$(-1.3,2.7,2.71)^{T}$は要素3の順序付きベクトルです。順序付きベクトルは順序ロジスティック回帰モデル(セクション9.8をみてください)のカットポイントとして使われることが最も多いでしょう。

変数`c`を要素5の順序付きベクトルとして宣言するには，

```
orderd[5] c;
```

のようにします。

順序付きベクトルであることを宣言した後で，ユニットシンプレックス型のように，他のベクトルを割り当てたり，他のベクトルに割り当てられたりすることができます。制約が保たれているかどうかは，変数が宣言されたブロックが実行された後にチェックされます。

#### 正の順序付きベクトル型

正の順序付きベクトルは，順序付きベクトルと同じように操作しますが，全ての要素が正の数でなければなりません。例えば，$(2,3,7.4,12.9)$は正の，要素数4の順序付きベクトルです。

変数`d`が要素5の順序付きベクトルであると宣言するには，

```
positive_ordered[5] d;
```

のようにします。

順序付きベクトルのように，正の順序付きベクトルと宣言した後は，他のベクトルに割り当てたり，他のベクトルに割り当てられたりすることができます。制約は変数が宣言されたブロックが実行された後にチェックされます。

#### 行ベクトル

行ベクトルはキーワード`row_vector`を使って宣言されます。(列の)ネクトルのように，サイズとともに宣言します。例えば，1093次元の行ベクトル`u`は，

```
row_vector[1093] u;
```

のように宣言します。

ベクトルと同じように，次の例では要素10のベクトルの値が-1から1の間に入るように制約をかけています。

```
row_vector<lower=-1,upper=1>[10] u;
```

行ベクトルは列ベクトルに割り当てることはできませんし，列ベクトルも行ベクトルに割り当てることはできません。もし割り当てがひつようでれば，転置の演算子を使って合わせることができます。

#### 行列

行列はキーワード`matrix`を使って，行と列の数とともに宣言します。たとえば，

```
matrix[3,3] A;
matrix[M,N] B;
```

は，行列Aが3 × 3で，行列Bが$M \times N$ 行列です。二つ目の宣言の仕方も形式はあっていて，変数$M$と＄N$が整数として，行列の宣言の前に，`data`あるいは　`tramsformed data`ブロックで宣言されていなければなりません。

行列は制約をつけて宣言することもできて，(3 × 4)の行列が正でな値をとるのであれば，次のようにします。

```
matrix<upper=0>[3,4] B;
```

##### 行列の行に割り当てる

行列の行には，割り当て文の左側のインデックスを使って割り当てをすることができます。例えば，次のようにできます。

```
matrix[M,N] a;
row_vector[N] n;
// ...
a[1] = b;
```

これはベクトル`b`の値を行列`a`の第一行目，`a[1]`にコピーします。もし`a`の列数が`b`のサイズと同じでないならば，実行時エラーが返されます。`a`の行数は`N`で，`b`のサイズと同じです。

Stanでは値をコピーすることで割り当てを行います。これが意味するのは，`a[1]`に割り当てた後は`b`に何も影響しないし，そのあと`b`に割り当てても`a`に影響しないということです。

#### 相関行列

行列型は相関行列を表現するために制約をかけることができます。ある行列が相関行列だというのは，それが対称で正定値行列であることで，その要素が-1から1の間にあり，対格項は1であるということです。相関行列は正方行列なので，宣言に際して必要な数字は一時限だけです。例えば，

```
corr_matrix[3] Sigma;
```

とすることで，`Sigma`は3 × 3の相関行列になります。

相関行列は，次元が同じであれば，制約のない他の行列に割り当てることができますし，その逆もまた可能です。

#### 相関行列のコレスキー因子

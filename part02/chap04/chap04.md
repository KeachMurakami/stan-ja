## 4. 式
式は、Stanのプログラムで値を示す基本文法単位です。整形式のStanのプログラムでは式はすべて、静的に（コンパイル時に）決定される型を持ちます。式の型を静的に決定できないときには、Stanのコンパイラは、この問題がある位置を報告します。

この章では、Stanにおける式の文法、型決定、さまざまな形での使い方について扱います。

### 4.1. 数値リテラル

最も単純な形式の式は、プリミティブな数値を示すリテラルです。

#### 整数リテラル

整数リテラルは`int`型の整数を表します。整数リテラルは、セパレータなしで10進基数で書かれます。整数リテラルには、単一の負符号を含めることができます（`--1`という式は、リテラル`-1`を負にしたものと解釈されます）。

以下は、整形式の整数リテラルです。

```
0, 1, -1, 256, -127098, 24567898765
```

整数リテラルは、整数値の上下限の間に収まる値をとる必要があります（2.2節を参照）。

整数リテラルには、小数点（`.`）を含めることができません。したがって、`1.`も`1.0`も`real`型の式であり、`int`型の値が必要な場所で使うことはできません。

#### 実数リテラル

ピリオドあるいは科学記法を含めて書かれた数は、連続値の数値型である`real`型に割り当てられます。実数リテラルは、ピリオド（`.`）をセパレータとする10進数で書かれます。以下は、整形式の実数リテラルの例です。

```
0.0, 1.0, 3.14, -217.9387, 2.7e3, -2E-5
```

`e`または`E`の後に正あるいは負の整数を続けた記法は10の累乗をかけることを示します。例えば、`2.7e3`は$2.7 \times 10^3$を示し、`-2E-5`は$-2 \times 10^{-5}$を示します。

### 4.2. 変数

変数はそれ自身が、その変数と同じ型を持つ整形式の式です。Stanの変数はASCIIの文字列からなり、含めることができるのは、基本的な小文字と大文字のローマ文字、数字、アンダースコア（`_`）文字のみです。変数は、文字（`a-z`と`A-Z`）で始めなくてはならず、2個のアンダースコア（`__`）で終わってはなりません。

以下は、正しい変数識別子の例です。

```
a, a3, a_3, Sigma, my_cpp_style_variable, myCamelCaseVariable
```

RおよびBUGSとは異なり、Stanの変数識別子はピリオド文字を含めることができません。

#### 予約語

Stanは、内部用に多くの文字列を予約しており、同じ名前の変数を使うことはできません。内部用の文字列と同じ名前を変数につけようとすると、`stanc`トランスレーターはエラーメッセージを出して止まり、使われようとした予約名と、モデルコード中の位置を示します。

##### モデルの名前

モデルの名前を、そのモデル内で変数に使うことはできません。これは普通は問題にはなりません。デフォルトでは`bin/stanc`が、モデル指定を含むファイルの名前の後に`__model`を加えるからです。例えば、モデルが`foo.stan`というファイルにあるとき、`bin/stanc`によるデフォルトのモデル名を使うなら、`foo_model`という名前の変数は使えません。ユーザーがモデルの名前を指定するときは、変数はモデルの名前と同じにはできません。

##### ユーザー定義関数の名前

ユーザー定義関数の名前をモデル中の変数に使うことはできません。

##### Stan言語由来の予約語

以下のリストは、Stanのプログラミング言語に予約されているワードです。Stanではまだ実装されていないものもありますが、これらトークンは将来の使用のために予約されています。

```
for, in, while, repeat, until, if, then, else, true, false
```

変数には、型と同じ名前もつけてはいけません。したがって、以下のいずれも使えません。

```
int, real, vector, simplex, unit_vector, ordered,
positive_ordered, row_vector, matrix, cholesky_factor_corr,
cholesky_factor_cov, corr_matrix, cov_matrix.
```

変数名は、以下のブロック識別子と衝突は**しません**。

```
functions, model, data, parameters, quantities, transformed,
generated
```

##### Stanの実装による予約語

StanのC++実装で使われているために予約されている変数名もあります。

```
var, fvar, STAN_MAJOR, STAN_MINOR, STAN_PATCH, STAN_MATH_MAJOR,
STAN_MATH_MINOR, STAN_MATH_PATCH
```

##### 予約されている関数名と分布名

あらかじめ定義されている関数の名前と変数名とは衝突します。定数とは衝突しません。したがって、変数に`logit`や`add`という名前を付けることができませんが、`pi`や`e`という名前を付けることはできます。

変数名はまた、`_lpdf`、`_lpmf`、`_lcdf`、`_lccdf`、`_cdf`、`_ccdf`という接尾辞の分布名、たとえば`normal_lcdf`（訳注: 原文の`normal_lcdf_log`は誤り）とも衝突します。これは、非推奨となった`_log`、`_cdf`、`_cdf_log`、`_ccdf_log`についても同様です。

こうした変数名のいずれかを使うと、`stanc`トランスレーターは停止し、衝突を起こした変数の名前と位置を報告することになります。

##### C++由来の予約語

最後に、モデル名を含む変数名は、C++のキーワードのいずれとも衝突してはいけません。

```
alignas, alignof, and, and_eq, asm, auto, bitand, bitor, bool,
break, case, catch, char, char16_t, char32_t, class, compl,
const, constexpr, const_cast, continue, decltype, default, delete,
do, double, dynamic_cast, else, enum, explicit, export, extern,
false, float, for, friend, goto, if, inline, int, long, mutable,
namespace, new, noexcept, not, not_eq, nullptr, operator, or, or_eq,
private, protected, public, register, reinterpret_cast, return,
short, signed, sizeof, static, static_assert, static_cast, struct,
switch, template, this, thread_local, throw, true, try, typedef,
typeid, typename, union, unsigned, using, virtual, void, volatile,
wchar_t, while, xor, xor_eq
```

#### 使用可能な文字

変数に使用可能な文字は、0--127の範囲のASCIIコードポイントのもので、これはユニコードでも同じです。

|  文字   | ASCII（ユニコード）コードポイント |
|:------:|:-----------------------------:|
| a -- z |            97 -- 122          |
| A -- Z |            65 --  90          |
| 0 -- 9 |            48 --  57          |
|   _    |               95              |

もっとも表現力豊かな文字セットとは言えませんが、ASCIIはもっとも広く利用可能で、不適切な文字エンコーディングやデコーディングをされてももっとも文字化けしにくいのです。

##### コメントではASCII互換のエンコーディングを使用可能

コメント内では、ASCIIと互換性のある文字エンコーディングを使用することができます。これには、ASCII自身やUTF-8、Latin1が含まれます。そのような文字を正しく表示できるかは、ユーザーのシェルやエディターに依存します。

### 4.3 ベクトル，行列，配列の式

Stanのコンテナオブジェクトの配列，ベクトル，行列の式は，配列の中括弧や，ベクトルや行列を表す大括弧で囲まれた一連の式で表現することができます。

#### ベクトルの式

カンマ区切りのプリミティブ表現の周りを囲む大括弧で，行ベクトルを表現することができます。例えば，`[1, 10, 100]`とすれば，三つの実数の値，1.0,10.0,100.0を要素とする行ベクトルを表したことになります。転置の演算子を行ベクトルに施すと，ベクトルの式になります。次の書き方は，一行で小さなベクトルを宣言したり定義したりする方法の一つです。

```
row_vector[2] rv2= [1,2];
vevtor[3] v3 = [3,4,5];
```

ベクトルの式の値は式や変数名をつかって更生することができ，`[2 * 3, 1 + 4]`あるいは`[x,y]`のように書くこともできます。ここで`x`と`y`はプリミティブな変数です。

#### 行列の式

行列の表現は，カンマ区切りの一連の行ベクトル周りを大括弧で囲ったものから構成されます。この書き方は，一行で宣言したり定義したりする方法の一つで，次のようにします。

```
matrix[3,2] m1 = [[1,2],[3,4].[5,6]];
```

行ベクトルを表すどのような式も，行列表現で使うことができます。例えば，以下のようなコードの書き方ができます。

```
vector[2] vX = [1,10]';
row_vector[2] vY = [100, 1000];
matrix[3,2] = [vX', vY, [1,2]];
```

##### 空のベクトルや行列の表現はダメです

空を表す表現`[ ]`は曖昧なので許されておらず，同様に`[ [ ] ]`や`[ [ ] , [ ] ]`のような表現も許されていません。

#### 配列式

式の列を中括弧で囲むと、配列式となります。例えば、`{ 1, 10, 100 }`という式は、1, 10, 100という3つの要素からなる整数配列を表します。この文法は、以下のように、小さな配列を1行で定義するのにとくに便利です。

```
int a[3] = { 1, 10, 100 };
```

値は、複合式でも構いません。つまり、`{ 2 * 3, 1 + 4}`と書いても正しい式です。また、以下の例のように、2次元配列を直接書くこともできます。

```
int b[2, 3] = { { 1, 2, 3 }, { 4, 5, 6 } };
```

このとき、`b[1]`は`{ 1, 2, 3 }`で、`b[2]`は`{ 4, 5, 6 }`です。

Stanでは、ホワイトスペースはどれも同じ扱いですから、上の例は、以下のように並べる方が、行と列の構造で2次元配列になっていることをよりはっきりさせることができます。

```
int b[2, 3] = { { 1, 2, 3 },
                { 4, 5, 6 } };
```

#### 配列式の型

式の型がどんなものであっても、括弧で囲めば配列式となります。もっとも単純な場合では、要素のすべてが同じ型で、その型の要素からなる配列が結果となるというものでしょう。例えば、配列の要素がベクトルのこともあります。その場合、結果はベクトルの配列となります。

```
vector[3] b;
vector[3] c;
...
vector[3] d[2] = { b, c };
```

また要素には、`int`型と`real`型の式が混ざっていても構いません。この場合、結果は実数値の配列となります。

```
real b[2] = { 1, 1.9 };
```

#### 値の制限

配列式は使い方にいくつか制限があります。これは、型がボトムアップで計算されることと、Stanの基本データ型および代入規則から生じます。

##### 配列式は矩形型だけ

不ぞろいな配列式を定義したくなることもありますが、Stanのデータ型はすべて矩形（あるいは直方体や、それを高次に一般化したもの）です。したがって、以下のようなネストした配列式は、矩形ではない配列をつくろうとしたところでエラーとなります。

```
{ { 1, 2, 3 }, { 4, 5 } } // コンパイル時エラー: サイズのミスマッチ
```

これは、1次元の整数配列（`int[ ]`）2個からなる2次元の整数配列（`int[ , ]`）をつくるものなので、大丈夫に見えるかもしれません。しかし、2個の1次元配列が同じサイズではないので、許されません。要素が配列式のときは、これはコンパイル時に検査されます。一方あるいは両方の式が変数のときは、実行時までエラーにならないでしょう。

```
{ { 1, 2, 3 }, m } // mのサイズが3でなければ実行時エラー
```

##### 空の配列式はありません

結果の型を推測する方法がないことから、空の配列式（`{ }`）は許されません。これは表現力を犠牲にするものではありません。なぜなら、要素数がゼロの配列として初期化するように宣言すれば十分だからです。

```
int a[0];   // aは要素数がゼロの配列として完全に定義されます
```

##### 整数のみの配列式

配列式の要素が、`{ 1, 2, 3 }`のように整数のみであれば、結果の型は整数配列`int[]`となります。これは、以下のように書くのは**正しくない**ことを意味します。

```
real a[2] = { -3, 12 };  // エラー: int[]はreal[]に代入できません
```

整数配列は実数値に代入できません。しかし、実数リテラルの式を使えば、この問題は簡単に回避できます。

```
real a[2] = { -3.0, 12.0 };
```

これで型が合い、代入できるようになります。

### 4.4. グルーピングのための括弧

式を括弧で囲んだものもすべて式です。C++と同様に、しかしRとは異なり、丸括弧`(`および`)`が使用可能です。角括弧`[`および`]`は、配列のインデックス操作に予約されており、中括弧`{`および`}`は、文のグルーピングに予約されています。

括弧を使うと、部分式と演算子を明示的にグルーピングできます。括弧なしの場合、式`1 + 2 * 3`は、部分式`2 * 3`を持ち、`7`と評価されます。括弧を使った場合、式`1 + (2 * 3)`というふうに明示的にグルーピングできます。もっと大事なことは、式`(1 + 2) * 3`は、`1 + 2`を部分式として`9`と評価されるということです。

### 4.5. 算術および行列の式

整数値と実数値の式に対しStanでは、加算(`+`)、減算(`-`)、乗算(`*`)、除算(`/`)の基本2項算術演算子を普通に使うことができます。

整数式に関してはStanには剰余(`%`)の2項算術演算子があります。Stanにはまた、整数値と実数値の式に対する負の単項演算子があります。例えば、`n`と`m`を整数の変数とし、`x`と`y`を実数の変数とするとき、以下は正しい式です。

```
3.0 + 0.14, -15, 2 * 3 + 1, (x - y) / 2.0,
(n * (n + 1)) / 2, x / n, m % n
```

符号反転・加算・減算・乗算の演算子は、行列およびベクトル・行ベクトルにも拡張されています。アポストロフィ（`'`）として書かれる転値演算子もベクトル・行ベクトル・行列に使用可能です。行列演算の戻り値の型は、結果を格納できることが静的に保証できるもっとも小さな型となります。許容される入力の型と対応する戻り値の型の組み合わせについての詳細は、42章にすべて挙げてあります。

例えば、`y`と`mu`が`vector`型の変数で、`Sigma`が`matrix`型の変数のとき、以下の式は、整形式の`real`型の式です。

```
(y - mu)’ * Sigma * (y - mu)
```

式全体の型は、部分式から外側へ向かって推測されます。部分式`y - mu`は、変数`y`と`mu`が`vector`型の式なので`vector`型です。この式を転値した部分式`(y - mu)'`は`row_vector`型です。乗算は左から結合し、転値は乗算よりも優先順位が高いので、上の式は、以下の指定を完全に行った整形式のものと同じです。

```
(((y - mu)’) * Sigma) * (y - mu)
```

部分式`(y - mu)' * Sigma`の型は`row_vector`と推測されます。行ベクトルに行列を掛けた結果だからです。したがって、この式全体の型は、行ベクトルに（列）ベクトルを掛けた型、つまり`real`型となります。

Stanには、行列の要素ごとの乗算および除算演算子、`a .* b`および`a ./ b`があります。ループを置き換えて簡略化できますが、効率性の面では、ループ内で要素ごとに計算して代入するようプログラミングしたものと本質的には変わりません。例えば、以下のように宣言して、

```
vector[N] a;
vector[N] b;
vector[N] c;
```

このように代入するのと、

```
c = a .* b;
```

ループとでは同じ結果となり、効率もほぼ同じです。

```
for (n in 1:N)
  c[n] = a[n] * b[n];
```

Stanでは、整数と実数値の式の累乗（`^`）を使えます。累乗の戻り値の型は常に実数値です。たとえば、`n`と`m`が整数の変数で、`x`と`y`が実数の変数とすると、以下は正しい式です。

```
3^2, 3.0^-2, 3.0^0.14,
x^n, n^x, n^m, x^y
```

累乗は右から結合します。ですから、下の式は、

```
2 ^ 3 ^ 4
```

以下の、指定を完全に行った整形式と同じものです。

```
2 ^ (3 ^ 4)
```

#### 演算の優先順位と結合性

演算子の優先順位と結合性は、配列のインデックス操作や関数の適用といった組込みの文法と合わせて図4.1に表形式で示しました。その他の式形式の演算（関数の適用と添え字の指定）はどの算術演算よりも強く結合します。

優先順位と結合性は、式がどのように解釈されるかを決定します。加算は左結合ですから、式`a+b+c`は`(a+b)+c`と解釈されます。同様に、`a/b*c`は`(a/b)*c`と解釈されます。

乗算は加算よりも優先順位が高いので、式`a*b+c`は`(a*b)+c`と解釈されますし、式`a+b*c`は`a+(b*c)`と解釈されます。同様に、`2*x+3*-y`は`(2*x)+(3*(-y))`と解釈されます。

転値と累乗は、ほかの算術あるいは論理演算よりも強く結合します。ベクトルと行ベクトル・行列に関しては、`-u'`は`-(u')`と、`u*v'`は`u*(v')`と、`u'*v`は`(u')*v`と解釈されます。整数と実数に関しては、`-n ^ 3`は`-(n ^ 3)`と解釈されます。

### 4.6 条件演算子

| 演算子 | 優先 | 結合 | 位置        | 説明                         |
|:------:|:----:|:----:|:------------|:-----------------------------|
| `? :`  |  10  |  右  | 3項間に入る | 条件                         |
| `\|\|` |   9  |  左  | 2項間に入る | 論理和                       |
| `&&`   |   8  |  左  | 2項間に入る | 論理積                       |
| `==`   |   7  |  左  | 2項間に入る | 等しい                       |
| `!=`   |   7  |  左  | 2項間に入る | 等しくない                   |
| `<`    |   6  |  左  | 2項間に入る | より小さい                   |
| `<=`   |   6  |  左  | 2項間に入る | より小さいか等しい           |
| `>`    |   6  |  左  | 2項間に入る | より大きい                   |
| `>=`   |   6  |  左  | 2項間に入る | より大きいか等しい           |
| `+`    |   5  |  左  | 2項間に入る | 加算                         |
| `-`    |   5  |  左  | 2項間に入る | 減算                         |
| `*`    |   4  |  左  | 2項間に入る | 乗算                         |
| `/`    |   4  |  左  | 2項間に入る | （右）除算                   |
| `%`    |   4  |  左  | 2項間に入る | 剰余                         |
| `\\`   |   3  |  左  | 2項間に入る | 左除算                       |
| `.*`   |   2  |  左  | 2項間に入る | 要素ごとの乗算               |
| `./`   |   2  |  左  | 2項間に入る | 要素ごとの除算               |
| `!`    |   1  |  n/a | 単項接頭    | 論理否定                     |
| `-`    |   1  |  n/a | 単項接頭    | 負                           |
| `+`    |   1  |  n/a | 単項接頭    | 正（Stanでは演算しない）     |
| `^`    |  0.5 |  右  | 2項間に入る | 累乗                         |
| `'`    |   0  |  n/a | 単項接尾    | 転値                         |
| `()`   |   0  |  n/a | 接頭,前後   | 関数の適用                   |
| `[]`   |   0  |  左  | 接頭,前後   | 配列・行列のインデックス操作 |

図4.1: Stanの単項・2項・3項演算子における、優先順位、結合性、式中の位置と説明。最後の2行は関数適用と、配列・行列・ベクトルのインデックス操作です。演算子は、優先順位にしたがって載せており、上の方がより弱く、下の方がより強く結合します。正しい引数と、対応する戻り値の組み合わせ全体は、第7部の関数の説明のうち、`operator`が前にあるものを見てください（たとえば`operator*(int, int):int`は、乗算演算子を2つの整数に適用し、整数を返すことを示しています）。括弧は、優先順位と結合性に依存せず、明示的に式をグルーピングするのにも使われます。

### 4.6. 条件演算子

#### 条件演算子の文法

3項条件演算子は、3つの引数をとるところと、複合構文をつかうというところで独特です。`a`が`int`型の式で、`b`と`c`が互いに変換できる（すなわち`==`で比較できる）式のとき、

```
a ? b : c
```

上の式は`b`と`c`とで昇格した型の式になります。Stanで認められている昇格は、整数から実数のみです。一方が`int`型で他方が`real`型のとき、条件式は全体として`real`型になります。その他の場合はすべて、これら引数は同じStanの基本型である必要があり（この際重要なのは、制約ではなく形式です）、条件式はその型となります。

##### 条件演算子の優先順位

条件演算子はもっとも優先順位が低い演算子です。そのため、あいまいさを避けるために引数に括弧を使う必要があることは稀です。例えば、

```
a > 0 || b < 0 ? c + d : e - f
```

は、明示的にグルーピングした以下の式と等価です。

```
(a > 0 || b < 0) ? (c + d) : (e - f)
```

括弧は厳密には必要ないとしても、後者の方が読みやすいでしょう。

##### 条件演算子の結合性

条件演算子は右から結合します。つまり、

```
a ? b : c ? d : e
```

は、明示的にグルーピングすると以下のようになります。

```
a ? b : (c ? d : e)
```

前と同じく、明示的にグルーピングした方が読みやすいでしょう。

#### 条件演算子の意味

Stanの条件演算子は、C++にあるものとほとんど同様に動作します。最初の引数は、整数となる式でなくてはなりません。普通ここは、上の例の`a`のように変数または関係演算子です。次に2つの結果の引数があり、1番目は条件が真（すなわち非零）の場合、2番目は条件が偽（すなわち零）の場合のものです。上の例では、条件が非零値と評価されれば`b`の値が返され、条件が例と評価されれば`c`が返されます。

##### 結果の遅延評価

なぜ高性能計算で条件演算子がとても有用かというと、戻り値となる部分式のみが評価され、そうでない式は評価されないという特性が鍵です。言い換えると、通常の関数とは違って、関数に値を渡すために引数の式を残らず評価するということをしません。とくに、組込みの`if_else`関数よりも条件演算子の方がかなり高速になります。`if_else`関数はほかの関数と同様、呼び出されたときに3つの引数をすべて評価するのです。ほかの例と同じく、この節約のほとんどは、基本的な関数評価そのものではなく、導関数を計算しないことによります。

##### パラメータへの昇格

一方の戻り値の式がデータ値（定数と、`data`あるいは`transformed data`ブロックで定義される変数のみからなる式）であり、他方がそうではない場合、3項演算子は、データ値をパラメータ値に昇格させます。これにより、必要のない導関数の計算が起こる場合があり、完全な`if`-`then`条件文より効率的でなくなることがあります。以下はその例です。

```
data {
  real x[10];
  ...
parameters {
  real z[10];
  ...
model {
  y ~ normal(cond ? x : z, sigma);
  ...
```

上のコードはより効率的に（より明快ではなくとも）下のように書けます。

```
if (cond)
  y ~ normal(x, sigma);
else
  y ~ normal(z, sigma);
```

条件文は、条件演算子と同様、結果の文のひとつしか評価しません。この場合、変数`x`はパラメータには昇格せず、そのため、導関数の計算の間に連鎖律を伝播するとき、不要な計算はまったく行なわれません。

### 4.7. インデックス操作

Stanの配列・行列・ベクトルと行ベクトルはすべて、配列と同様の記法でアクセスします。例えば、`x`が`real[]`型（1次元の実数配列）なら、`x[1]`はその配列の1番目の要素の値です。

添え字は、ほかの算術演算子より高い優先順位にあります。例えば、`alpha*x[1]`は`alpha*(x[1])`と等価です。

複数の添え字は、1対の角括弧内の中で使用できます。`x`が、`real[ , ]`型、つまり2次元配列なら、x[2,501]は`real`型です。

#### 部分配列へのアクセス

添え字演算子は配列の部分配列も返します。例えば、`x`が`real[ , , ]`型のとき、`x[2]`は`real[ , ]`型で、`x[2,3]`は`real[]`型です。結果として、式`x[2,3]`は`x[2][3]`と同じ意味になります。

#### 行列の行へのアクセス

`Sigma`が`matrix`型の変数のとき、`Sigma[1]`は`Sigma`の1番目の行を指し、`row_vector`型になります

#### 配列とベクトル/行列のインデックスを混ぜる

Stanでは、配列と、そのベクトル・行ベクトル・行列の値のインデックス操作とを混ぜることができます。例えば、`m`が`matrix[ , ]`型、つまり行列の2次元配列のとき、`m[1]`はこの配列の1番目の行を示し、その型は行列の1次元配列となります。2つ以上のインデックスも使うことができます。`m[1,2]`は`matrix`型で、この配列の1番目の行と2番目の列にある行列を示します。インデックスをさらに増やすと、`m[1,2,3]`は`row_vector`型で、`m[1,2]`が指す行列の3行目を示します。最後に、`m[1,2,3,4]`は`real`型で、配列`m`の1行2列にある行列の3行4列の値を示します。

### 4.8. 複数インデックス操作と範囲インデックス操作

4.7節で述べた整数の単一インデックスに加え、Stanでは複数インデックス操作が使えます。複数インデックスには、インデックスの整数配列や、下限、上限、上下限、あるいはインデックス全体を簡略化したものがあります。インデックスの種別を全部しめした表は図4.2になります。

| インデックス型 |    例    |             値            |
|:--------------:|:--------:|:-------------------------:|
|     整数       | `a[11]`  | 11番目のインデックスの値  |
|    整数配列    | `a[ii]`  | `a[ii[1]], ..., a[ii[K]]` |
|      下限      | `a[3:]`  | `a[3], ..., a[N]`         |
|      上限      | `a[:5]`  | `a[1], ..., a[5]`         |
|      範囲      | `a[2:7]` | `a[2], ..., a[7]`         |
|      全体      | `a[:]`   | `a[1], ..., a[N]`         |
|      全体      |  `a[]`   | `a[1], ..., a[N]`         |

図4.2: インデックスの型および、サイズ`N`の1次元コンテナと、サイズ`K`の`int[]`型整数配列`ii`の場合の例

#### 複数インデックス操作の意味

複数インデックス操作を扱う場合の意味について、その基本則は次の通りです。`idxs`が複数インデックスの場合、結果にはインデックス操作が可能な位置が生成されます。つまり、結果のインデックス位置を評価する際、まず複数インデックスに添え字が渡され、その結果得られるインデックスが使われることになります。

```
a[idxs, ...][i, ...] = a[idxs[i], ...][...]
```

一方、`idx`が単一インデックスとのときには、出力の次元が削減されます。

```
a[idx, ...] = a[idx][...]
```

問題となるのは、行列とベクトルのときどうなるかだけです。ベクトルは配列とまったく同様です。行に複数インデックスにつけ、列にも複数インデックスをつけた行列は、行列になります。行に複数インデックスをつけ、列に単一インデックスをつけた行列は、（列）ベクトルになります。行に単一インデックスをつけ、列に複数インデックスをつけた行列は、行ベクトルになります。これらの型は図4.3にまとめてあります。

|    式     | 行インデックス | 列インデックス |  結果の型  |
|:---------:|:--------------:|:--------------:|:----------:|
|   a[i]    |      単一      |       n/a      | 行ベクトル |
|   a[is]   |      複数      |       n/a      |    行列    |
|  a[i, j]  |      単一      |      単一      |    実数    |
| a[i, js]  |      単一      |      複数      | 行ベクトル |
| a[is, j]  |      複数      |      単一      |  ベクトル  |
| a[is, js] |      複数      |      複数      |    行列    |

図4.3: 引数が単一か複数かによって行列の次元が削減される特別な規則。この例では、`a`が行列、`i`と`j`が整数の単一インデックス、`is`と`js`が整数配列の複数インデックス。同じ型の規則がすべての複数インデックスに適用されます。

複数インデックスをつけた行列の評価は、以下の分配条件にしたがって定義されます。

```
m[idxs1, idxs2][i, j] = m[idxs1[i], idxs2[j]]
m[idxs, idx][j] = m[idxs[j], idx]
m[idx, idxs][j] = m[idx, idxs[j]]
```

行列の配列およびベクトル・行ベクトルの配列の評価は、配列の次元からはじまり、再帰的に定義されます。

### 4.9. 関数適用

Stanには、幅広い種類の数学および統計関数が組み込まれており、それについては第7部で説明しています。

Stanの式には、関数名と、その後に続く0個以上の引数の式からなっているものもあります。例えば、`log(2.0)`は`real`型の式で、実数リテラル`2.0`の値を自然対数に適用した結果を示しています。

文法的には、関数適用はほかのどの演算子よりも高い優先順位を持ちますから、`y + log(x)`は`y + (log(x))`と解釈されます。

#### 型のシグネチャと結果の型の推測

関数はおのおの、引数と戻り値にとりうる型を決めている型のシグネチャがあります。例えば、対数関数のシグネチャは以下のように表されます。

```
real log(real);
```

`lmultiply`関数のシグネチャは以下です。

```
real lmultiply(real,real);
```

関数は、その名前と、引数の型の並びとによって、ただひとつに決定されます。たとえば、以下の2つの関数は別々の関数です。

```
real mean(real[]);
real mean(vector);
```

1番目は、実数値の1次元配列に適用され、2番目はベクトルに適用されます。

関数の同一性条件により、同じ名前と引数の型を持ちながら戻り値の型が異なる2つの関数をつくることは明示的に禁止されています。この制限により、関数の式の型を構成から推測するのに、その部分式の型を調べればよくなってもいます。

#### 定数

Stanの定数は、引数なしの関数に過ぎません。例えば、数学定数$\pi$と$e$は引数なし関数`pi()`と`e()`です。組込み定数の一覧は39.2節を参照してください。

#### 型の昇格と関数の多重定義の解決

整数型は実数型に昇格するので、一連の引数の型が与えられた場合、どの関数が呼ばれるのか、規則を決めておく必要があります。Stanで採用されているのは、C++で使われているものと同じやり方です。すなわち、必要とする型の昇格の数を最小にする関数を呼び出すように解決しています。

例えば、以下の2つの関数シグネチャが`foo`に登録されているとします。

```
real foo(real,real);
int foo(int,int);
```

式`foo(1.0,1.0)`で`foo`を使うと、`foo(real,real)`と解決されます。したがって、式`foo(1.0,1.0)`自体には`real`型が割り当てられます。

整数は実数に昇格することがありますから、式`foo(1,1)`は潜在的には`foo(real,real)`と`foo(int,int)`のいずれにも当てはまります。前者では型の昇格が2回必要ですが、後者ではその必要がありません。したがって、`foo(1,1)`は関数`foo(int,int)`と解決され、`int`型が割り当てられます。

式`foo(1,1,0)`は引数の型が`(int,real)`なので、明示的にはどの関数シグネチャにも当てはまりません。整数式`1`が`real`型に昇格することにより、`foo(real,real)`に当てはめることができ、したがって関数式`foo(1,1.0)`の型は`real`です。

（Stanの組込み関数にはありませんが）式からはどの関数が参照されるのか多義的で決められないという状況もありえます。例えば、以下のシグネチャをもつ、まさに2つの関数があるという場合を考えましょう。

```
real bar(real,int);
real bar(int,real);
```

シグネチャからは、式`bar(1.0,1)`と`bar(1,1.0)`は、それぞれ上の関数の1番目と2番目と解決されます。実数値は整数に降格できませんから、式`bar(1.0,1.0)`は誤りです。式`bar(1,1)`は別の理由で誤りです。1番目の引数が実数値に昇格すれば、1番目のシグネチャに当てはまりますが、2番目の引数が実数値に昇格すれば、2番目のシグネチャに当てはまります。問題は、両方とも1回の昇格を必要とするということにあり、したがって関数`bar`は多義的となります。上の`bar(1, 1)`のように二つを超える解釈が存在する場合、ほかの関数よりもより少ない回数の昇格を必要とする関数がただ1つでないときには、Stanのコンパイラは式が誤りであるというフラグを立てます。

#### 乱数発生関数

Stanにある分布のほとんどには、対応する乱数発生関数があります。これら乱数発生器は、分布に`_rng`という接尾辞をつけた名前となっています。例えば、1変量正規乱数は`normal_rng(0,1)`で生成できます。変量は生成されますから、分布のパラメータ、ここでは位置(0)とスケール(1)のみを指定します。

##### 乱数発生器の場所

乱数発生関数の使用は、`transformed data`あるいは`generated quantities`ブロックに限られます。ほかの場所で使おうとすると、パースエラーとなり診断メッセージが出力されます。このほか、名前が`_rng`で終わるユーザー定義関数の本体でも使うことができます。

これにより、乱数生成関数は一般にシミュレーションのために利用することができますが、特にベイジアン事後予測のチェックのために使えます。

##### 事後予測チェック

事後予測チェックは通常、モデルのパラメータを使って、（個体レベルで、階層モデルでは群レベルでも）シミュレートしたデータを生成します。これにより、見た目ならグラフにプロットして、正式には検定統計量を使って、実際のデータと比較することにより、モデルの適合性を調べることができます。事後予測チェックについてさらに知るにはGelman et al. (2013)の6章を参照してください。

### 4.10 型の推定

Stanは強い静的型付けをします。これは、式の実装の型がコンパイル時に解決できることを意味します。

#### 実装の型

Stanでは、プリミティブな実装の型は、`int`、`real`、`vector`、`row_vector`、`matrix`です。基本的な型宣言はすべて、プリミティブな型と対応しています。型と、そのプリミティブな型との対応は図4.4を参照してください。実装の型は完全には、プリミティブな実装の型と、0以上の整数配列の次元数からなります。これらを記述する際には、配列としての特徴が強調されることになるでしょう。例えば、`int[]`は次元数1の配列で、`int`は次元数0の配列で、`int[ , , ]`は次元数3の配列です。`matrix[ , , ]`という実装型は全部で5の次元数を持ち、そのうちの3つは配列のもので、2つは行列のものです。

式では、配列の次元は、行列やベクトルの次元の前に来るということを思い出してください。以下の宣言は、行列の3次元配列の例です。

```
matrix[M, N] a[I, J, K];
```

この行列は`a[i, j, k, m, n]`と添え字が付きます(配列のインデックスが先で、その後が行列のインデックスです)ので、`a[i, j, k]`は行列で、`a[i, j, k, m]`は行ベクトルとなります。


|           型           | プリミティブな型 |
|:----------------------:|:----------------:|
|         `int`          |       `int`      |
|         `real`         |       `real`     |
|        `matrix`        |      `matrix`    |
|      `cov_matrix`      |      `matrix`    |
|      `corr_matrix`     |      `matrix`    |
| `cholesky_factor_cov`  |      `matrix`    |
| `cholesky_factor_corr` |      `matrix`    |
|        `vector`        |      `vector`    |
|        `simplex`       |      `vector`    |
|     `unit_vector`      |      `vector`    |
|        `ordered`       |      `vector`    |
|   `positive_ordered`   |      `vector`    |
|      `row_vector`      |    `row_vector`  |

図4.4: Stanの変数宣言の型と対応するプリミティブな実装の型の表。Stanの関数・演算子・確率関数は引数と戻り値の型を持ち、それらはプリミティブな型と配列次元数によって宣言されます。

#### 型推定の規則

Stanの型推定規則は、変数宣言の背後にある組み合わせに基づいて、ある式の実装の型を定義します。この規則は、プリミティブなリテラルと変数の式から、複合した式へとボトムアップに作用します。

##### リテラル

`42`のような整数リテラルの式は`int`型です。`42.0`のような実数リテラルは`real`型です。

##### 変数

局所的に、あるいは前のブロックで宣言された変数の型はその宣言で決定されます。ループ変数の型は`int`です。

各変数の宣言は、スコープ毎に常に唯一となります。Stanでは、既に宣言された変数をもう一度宣言することを禁止しているからです。^[C++やRのような言語では、ある名前の変数を、より狭いスコープで宣言し、それを含むスコープで定義された変数を隠蔽する（評価時に優先する）ことが許されています。]

##### インデックス操作

`x`が全体の次元数が$N$以上の式であっても、式`e[i1, ..., iN]`の型が`e[i1]...[iN]`と同じことからもわかるように、単一インデックスによる型が定義できれば説明には十分です。`e`を式、`i`をプリミティブな型が`int`の式とします。すると、以下のようになります。

- `e`が、次元数$K > 0$の配列の式のとき、`e[i]`は、次元数$K - 1$であり、`e`と同じプリミティブな実装の型を持ちます。
- `e`の実装型が、次元数0の配列の`vector`あるいは`row_vector`のとき、`e[i]`の実装型は`real`です。
- `e`の実装型が`matrix`のとき、`e[i]`の型は`row_vector`です。

##### 関数適用

`f`が関数の名前で、$N \ge 0$で`e1,...,eN`が式のとき、`f(e1,...,eN)`は式で、その型は、`e1`から`eN`に対する`f`の関数シグネチャでの戻り値で決定されます。関数シグネチャは、引数の型と戻り値の型の宣言であることを思い出してください。

関数を調べるとき、`real * real`のような2項演算子は、ドキュメントや索引では`operator*(real,real)`というふうに定義されています。

関数の定義を照合するとき、`int`型の引数は必要に応じて`real`型に昇格する場合があります（Stanの整数-実数の型昇格規則についての正確な仕様は、4.9節の型昇格についての小節を参照してください）。

一般に行列演算は、推測される型の中でもっとも低い次元のものを返します。例えば、`row_vector * vector`は`real`型の値を返します。この演算子は、関数のドキュメントと索引では`real operator*(row_vector,vector)`と宣言されています。

### 4.11. 連鎖律と導関数

モデルにより定義される対数確率関数の導関数は、Stanでは何通りかで使われます。NUTSを含むハミルトニアンモンテカルロサンプラーでは、更新を動かすのに勾配を使います。BFGSオプティマイザーも、事後最頻値の探索を動かすのに勾配を使います。

#### 連鎖律によるエラー

純粋に数学的に評価するのとは異なり、Stanでの導関数の評価は、浮動小数点演算を使った評価で、式ごとに連鎖律を適用することにより行なわれます。その結果、以下のようなモデルでは導関数に関係した推定に問題が発生します。

```
parameters {
  real x;
}
model {
  x ~ normal(sqrt(x - x), 1);
}
```

代数的には、このサンプリング文は以下のように簡単にできるでしょう。

```
x ~ normal(0, 1);
```

そしてこのモデルは、`x`について単位正規分布のサンプルを生成するように思えます。このように相殺しておかないと、式`sqrt(x - x)`は、導関数に問題を発生させます。原因は、連鎖律を機械的に評価するためです。

![$$\begin{array}{rl} \frac{d}{dx}\sqrt{x - x} &= \frac{1}{2\sqrt{x - x}}\times\frac{d}{dx}(x - x)\\ &= \frac{1}{0}\times(1 - 1)\\ &= \infty \times 0 \\ &= \mathrm{NaN} \end{array}$$](fig/fig01.png)

$x - x$が消去されるのではなく、連鎖律の評価の分子と分母に0を発生させます。

この種の問題を避ける唯一の方法は、必要な代数的消去をモデルの一部として注意深く行ない、連鎖律が非数値(NaN)を生成する`sqrt(x - x)`のような式を組み込まないようにすることです。

#### 導関数の問題の診断

導関数で何か問題が発生しているかどうかを診断するもっともよい方法は、サンプラーあるいはオプティマイザーの入力で勾配テストのオプションを使うことです。このオプションは、StanでもRStanでも使えます（ただし遅くなるかもしれません。組込みの自動微分と比較するために有限差分に依存するからです。）。

例えば、上のモデルを実行形式`sqrt-x-minus-x`にコンパイルすると、以下のようにテストできます。

```
> ./sqrt-x-minus-x diagnose test=gradient
...
TEST GRADIENT MODE
 Log probability=-0.393734
 param idx           value           model     finite diff           error
         0       -0.887393             nan               0             nan
```

有限差分が勾配を正しく0と計算しているにもかかわらず、自動微分は連鎖律に従い、非数値の出力を生成しています。

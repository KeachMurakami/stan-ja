## 5. 文（ステートメント）

<!--
statement を "文" とした場合、以降説明にて何を指しているか
読み取りにくくなるためカタカナとした
-->

Stan プログラムのブロック (6章を参照) は、変数の宣言と文（ステートメント）
から成り立っています。BUGS と違って、Stan プログラム中の宣言と文はそれらが
記載された順序で実行されます。変数は、それが参照される前に何らかの値 (と何らかのデータ型の宣言)
によって定義されていなければいけません --- そうでない場合、実行結果は未定義となります。

Stanでは、与えられた（実数値の）パラメーターの組についての対数確率関数（具体的には確率密度関数）の評価が実行の基礎です。対数確率関数は、代入文を使って組み立てることができます。
また、いくつかの文は 連続した処理やfor-each ループの繰り返し処理にグルーピング
できるでしょう。加えて、Stan では ブロック内でのローカル変数の宣言や、セミコロンのみからなる
空の文も許容されています。

### 5.1. 代入文

代入文は変数と式からなります。変数はインデックス情報を持つ多変量の場合もあります。
代入文が実行されると、文の右辺にある式が評価され、
その結果が左辺の変数 (インデックスがある場合は指定された箇所) に代入されます。
簡単な代入の例は以下のようなものです。^[Stan の 2.16.0 より前のバージョンでは、代入には等号 `=`ではなく `<-` 演算子が用いられていました。
古い`<-` 演算子は現在では非推奨となり警告が表示されます。`<-` 演算子は将来のバージョンで削除されます。]

<!--
以降も原文には都度 (indexed) の記載があるが、日本語で簡潔に記載できる語がないため省略
-->

```
n = 0;
```

この文が実行されると、式`0`、つまり 整数のゼロが評価され、変数`n`に代入
されます。代入が成立するためには、右辺の式のデータ型と左辺の変数のデータ型は一致していな
ければなりません。上の例では、`0`という式は`int`型になるため、
変数`n`は`int`型もしくは`real`型で宣言されていなければなりません。
変数が`real`型で宣言されている場合は、整数のゼロは浮動小数点のゼロに変換されて
変数に代入されます。文が実行された後は、変数`n`はゼロ (変数のデータ型に応じて整数
もしくは浮動小数点) という値を持ちます。

文法的には、すべての代入文はセミコロンで終わっていなければなりません。
それ以外では、トークンの間の空白は処理に影響しません (ここでのトークンは左辺の変数、
代入演算子、右辺の式、セミコロンを指します)。

右辺の式が最初に評価されるため、Stan でも C++ や他のプログラミング言語と同じように
変数を変数をインクリメントすることができます。

```
n = n + 1;
```

このような自己代入は BUGS では許されていません。なぜなら、自己代入は
有向グラフィカルモデル中で循環を引き起こすからです。

代入文の左辺は配列、`matrix`、`vector`といったデータ構造に対するインデックスを
含むことがあります。例えば、`matrix`として定義された`Sigma`に対して、

```
Sigma[1, 1] = 1.0;
```

という代入文は、`Sigma`の1行1列目の値に`1`を代入します。

代入文にはあらゆるデータ型の複雑なオブジェクトを含むことができます。
`Sigma`と`Omega`が`matrix`、`sigma`が`vector`の場合、次の代入文は
成立します。変数のデータ型と式の結果はどちらも `matrix`型になるためです。

```
Sigma
  = diag_matrix(sigma)
     * Omega
     * diag_matrix(sigma);
```

また、この例は複雑な代入文を複数の行に分割して記載する場合に望ましい例を
示しています。

Stan は より大きな多変量のデータ構造の一部に対する代入もサポートしています。例えば、
`a`が`real[ , ]`型の配列、`b`が`real[]` 型の配列の場合、以下二つの
代入文はどちらも成立します。

```
a[3] = b;
b = a[4];
```

同じように、`x`が`row_vector`型、`Y`が`matrix`型の変数として
宣言されている場合、次の一連の処理は成立します。処理の結果、`Y`の最初の2行が
入れ替わります。

```
x = Y[1];
Y[1] = Y[2];
Y[2] = x;
```

#### 左辺値

代入文中の左辺として適切な式を“左辺値”と呼びます。Stan では、
適切な左辺値は以下の 2 種類しかありません。

- 一つの変数
- 一つ以上のインデックスを持つ一つの変数

インデックスのついた変数を左辺値として使うためには、その変数は少なくともインデックスと同じ数の
次元を持っていなければいけません。実数型や整数型の配列は宣言された数の次元を持ちます。
行列（`matrix`）は2次元、行列（`vector`）や列行列（`row_vector`）は1次元です。これは制約のついた型でも同様で、共分散行列（`cov_matrix`）と
相関行列（`corr_matrix`）、またそれらのコレスキー因子（`cholesky_factor_cov`、`cholesky_factor_corr`）や、順序つき（`ordered`）、正の順序つき（`positive_ordered`）、単体（`simplex`）のベクトルについてもあてはまります。
通常の配列と比べると、行列の配列の次元数は2だけ大きく、ベクトルや列ベクトルの配列の次元数は1だけ大きくなります。
インデックスの数は、変数の次元数よりも少なくてもよいことに注意してください。
このとき、右辺自身も多次元で、左辺の残りの次元と一致している必要があります。

#### マルチプルインデックス

マルチプルインデックスは4.8節で説明していますが、これも代入の左辺に使うことができます。左辺のインデックス操作は、式と同じように機能します。
このとき、マルチプルインデックスはインデックスの位置を保存し、シングルインデックスはインデックスを減少させます。
左辺の型はやはり右辺の型と一致していなくてはなりません。

##### エイリアス

すべての代入は、事前に右辺の式のをコピーしたかのようにして行われます。
これにより、「代入文の実行中に右辺の式の値が変更される」ことによって生じる、
エイリアスの潜在的な問題を解決しています。

### 26.2. 対数密度加算文

Stanでは、与えられた（実数値の）パラメーターの組についての対数確率関数（具体的には確率密度関数）の評価が実行の基礎です。
この関数は、加算する定数を除いて事後分布の対数密度を返します。
データと変換データは対数密度が評価される前に決められます。
対数確率の合計は零に初期化されます。
次に、対象の変数に制約がある場合に生じる対数ヤコビアンの調整が対数密度に対して加えられます 
(ヤコビアンの調整は最適化のために省略されることがあります)。
`model`ブロックでは、サンプリング文と対数確率加算文で対数密度への加算を行なうことができます。
対数確率加算文は、以下のような式の値を対数密度に直接加算します。^[この現在の記法は過去のふたつのバージョンに代わるものです。
元々は、変数`lp__`を直接参照したり操作することができました。これはもはや許可されていません。
`target += u`に対応する元の文法は`increment_log_prob(u)`ですが、この形式は非推奨となり Stan 3 で削除されます。]

```
target += -0.5 * y * y;
```

ここでの`target`というキーワードは実際には変数ではなく、変数のようにアクセスすることはできません
(が、特殊な関数を使って`target`の値に直接アクセスする方法がこの後にあります)。

この例では、標準正規分布にしたがう変数`y`の標準化されていない対数確率が対数確率の合計に加算されます。
一般的には、右辺はどのような式にもなりえます。^[乗算のほうが除算よりも効率的なため、このモデルでは式を`-0.5 * y * y`と書いたほうが、等価な`y * y / -2`よりも効率的です。
どちらの場合も、負数化は数値リテラル（`-0.5`や`-2`）に含められます。
`y * y`の代わりに`square(y)`と書くと導関数を事前に計算でき、
利用メモリと自動微分に必要な操作も減らすことができるためさらに効率的です。]

完全なStanモデルをこのようにして実装することができます。
たとえば、次のモデルは標準正規分布に従うひとつの変数を抽出します。

```
parameters {
  real y;
}
model {
  target += -0.5 * y * y;
}
```

このモデルでは対数確率関数を以下ように定義しています。

$$\log p(y) = -\frac{y^2}{2} - \log Z$$

ここで、$Z$は$y$に依存しない正規化定数です。
定数$Z$は慣例的にこのように書かれます。これは、線形スケールでの式が以下のようになるからです。

$$p(y) = \frac{1}{Z} \exp\left(-\frac{y^2}{2}\right)$$

上の式は通常は$Z$を使わず以下のように書かれます。

$$p(y) \propto \exp\left(-\frac{y^2}{2}\right)$$

Stanでは、パラメーターに依存しない定数を除いて定義したモデルしか必要としません。
正規化定数$Z$の計算には時間がかかったり評価がしにくいことがしばしばあるため、これは便利です。

#### ベクトル化

`target += ...`文は、`...`の部分の引数にどんな式でも入れることができます。
これには、整数、実数、ベクトル、列ベクトル、行列のほか、ベクトルや行列の配列を含むあらゆる次元数の配列を含みます。
引数がコンテナ型の場合はその要素の合計が対数密度に加算されます。

#### 対数密度へのアクセス

現在の実行ポイントの直前までの累積対数密度にアクセスするには`target()()`関数を使うことができます。

### 5.3. サンプリング文

Stanでは、以下のようなサンプリング記法でも確率文を書くことができます。

```
y ~ normal(mu,sigma);
```

「サンプリング文」という名前は示唆的な意味であり、文字通りに解釈するものではありません。
概念的には、変数`y`は、未知のパラメーターでも既知のモデリングされるデータでもよく、サンプリング文の右辺で示される分布を持つと宣言されています。

このような文を実行してもサンプリングはまったく行なわれません。Stanでは、サンプリング文は単に便利な記法に過ぎません。上のサンプリング文は以下と同様で、対数確率の合計に直接加算するということを表します。

```
target += normal_lpdf(y | mu, sigma);
```

一般に、以下の形式のサンプリング文

```
y ~ dist(theta1, ..., thetaN);
```

は、`y`と`theta1`から`thetaN`（`N`が零の場合も含みます）までの部分式からなり、対応する代入文が整形式の場合にのみ整形式となります。`y`の値が実数でよい密度については、以下のような対数確率密度関数が使われます。

```
target += dist_lpdf(y | theta1, ..., thetaN);
```

`y`の値が整数に制限されている場合は、対数確率質量関数が使われます。

```
target += dist_lpmf(y | theta1, ..., thetaN);
```

これは、`dist_lpdf(y | theta1, ..., thetaN)`あるいは`dist_lpmf(y | theta1, ..., thetaN)`が`real`型の整形式の式である場合にのみ、整形式となります。

#### 対数確率加算 vs. サンプリング文

以下のようなサンプリング文でも、

```
y ~ normal(mu, sigma);
```

以下のように対数確率関数を明示的に加算しても、

```
target += normal_lpdf(y | mu,sigma);
```

Stanでのサンプリングの挙動は同じになりますが、両者の間には1つ決定的な違いがあります。

サンプリング文は、定数となる対数確率関数の項をすべて捨てますが、明示的に`normal_lpdf`を呼ぶ場合には、定数の正規化項もすべて含め、対数正規確率関数の定義の項すべてを加算します。
したがって、明示的に加算する形式は、モデルの正確な対数確率の値を生成しなおすために使うことができます。一方、サンプリング文の形式は、入力の式である`y`や`mu`、`sigma`のすべてが定数、データ変数、変換データ変数のみを含む場合にはより高速です。

#### ユーザー定義の変数変換

サンプリング文の左辺は複合的な式でも構いません。たとえば、構文上正しく以下のように書けます。

```
parameters {
  real<lower=0> beta;
}
// ...
model {
  log(beta) ~ normal(mu, sigma);
}
```

残念ながらこのように書いても、`beta`が対数正規分布に従うと正しくモデリングしたことにはなりません。この例での`beta`に対数関数を適用する場合のように、非線形の変換をパラメーターに適用するときにはいつでも、微分の変化の帳尻を合わせ、`beta`が正しい分布となることを保証するため、調整を行なわなくてはなりません。必要な補正とは、変換の対数ヤコビアンを目的の対数密度に加算することです（完全な定義は34.1節を参照してください）。上の場合では、以下の調整が対数変換の補正となります。^[$\log |\frac{d}{dy}\log y | = \log | 1 / y | = -\log | y |$だからです。34.1節を参照してください。]

```
target += - log(fabs(y));
```

#### 切断分布

Stanでは、上限、下限、あるいは上下限のある切断分布を使えます。

##### 上限と下限での切断

連続分布の確率密度関数$p(x)$を区間$[a, b]$で切断して、$[a, b]$を台とする新しい密度$p_{[a, b]}$を定義できます。

$$p_{[a, b]}(x) = \frac{p(x)}{\int_a^b p(u)du}$$

離散分布の確率質量関数$p(x)$を閉区間$[a, b]$で切断できます。

$$p_{[a, b]}(x) = \frac{p(x)}{\sum_{u=a}^b p(u)}$$

##### 下限での切断

確率密度関数$p(x)$は以下の定義により$[a,\infty]$で切断できます。

$$p_{[a, \infty]}(x) = \frac{p(x)}{\int_a^\infty p(u)du}$$

確率質量関数$p(x)$は以下の定義により$[a,\infty]$で切断できます。

$$p_{[a, \infty]}(x) = \frac{p(x)}{\sum_{a<=u} p(u)du}$$

##### 上限での切断

確率密度関数$p(x)$は以下の定義により$[-\infty, b]$で切断できます。

$$p_{[-\infty, b]}(x) = \frac{p(x)}{\int_{-\infty}^b p(u)du}$$

確率質量関数$p(x)$は以下の定義により$[-\infty, b]$で切断できます。

$$p_{[-\infty, b]}(x) = \frac{p(x)}{\sum_{u<=b} p(u)du}$$

##### 累積密度関数

確率変数$X$についての確率関数$p_X(x)$が与えられたとき、その累積密度関数(cumulative distribution function: cdf)$F_X(x)$は、$X \le x$である確率として定義されます。

$$F_X(x) = \Pr[X \le x]$$

大文字の変数$X$は確率変数ですが、小文字の変数$x$はごく普通の限度のある変数です。連続値の確率変数については、cdfは以下のようになります。

$$F_X(x) = \int_{-\infty}^x p_X(u)du$$

離散値の変数については、cdfは引数で与えられた上限を含めて定義されます。

$$F_X(x) = \sum_{u \le x}p_X(u)$$

##### 相補累積分布関数

相補累積分布関数(complementary cumulative distribution function: ccdf)は、連続の場合も離散の場合も以下のようになります。

$$F_X^C(x) = \Pr[X > x] = 1 - F_X(x)$$

cdfとは異なり、ccdfは境界を含みません。cdfの事象は$X \le x$ですが、ccdfの事象は$X > x$だからです。

連続分布については、ccdfは以下のようになります。

$$F_X^C(x) = 1 - \int_{-\infty}^x p_X(u)du = \int_x^\infty p_X(u)du$$

積分の境界には下限を含めることができます。線上の1点であり、確率質量を持たないからです。
離散の場合は、$u > x$について総和をとる際に明示的に下限を除外しなければなりません。

$$F_X^C(x) = 1 - \sum_{u \le x} p_X(u) = \sum_{u > x} p_X(u)$$

累積分布関数は、切断分布を定義するのに必要な積分の計算に使われます。
上下限での切断では、分母は以下のように定義されます。

$$\int_a^b p(u)du = F_X(b) - F_X(a)$$

離散分布では、下の切断点が含まれない$F_X(b)-F_X(a)$に、この点を明示的に入れるためにやや複雑な形が必要です。

$$p_{[a, b]}(x) = \frac{p_X(x)}{F_X(b) - F_X(a) + p_X(a)}$$

##### Stanにおける上下限での切断

Stanでは確率関数を切断することができます。たとえば、$[-0.5, 2.1]$に制約される切断標準正規分布は以下のサンプリング文でコーディングできます。

```
y ~ normal(0, 1) T[-0.5, 2.1];
```

切断分布は、累積対数密度関数の追加の項に、サンプリング文中の変量が切断の上下限に含まれていることを保証するためのエラーチェックを加えて翻訳されます。

一般に、切断の上下限とパラメーターは、パラメーターあるいは局所変数でも構いません。

上の例では連続分布を含んでいるので、以下のより冗長な形式と同じ動作となります。

```
y ~ normal(0, 1);
  if (y < -0.5 || y > 2.1)
    target += negative_infinity();
  else
    target += -log_diff_exp(normal_lcdf(2.1 | 0, 1),
                            normal_lcdf(-0.5 | 0, 1));
```

Stanプログラムは対数密度関数を定義しますから、すべての計算は対数スケールで行なわれます。
`normal_lcdf`関数は累積正規分布関数の対数で、`log_diff_exp(a, b)`は、`log(exp(a) - exp(b))`をより算術的に安定にした形です。

離散分布では、下限を除くために分母にもうひとつの項が必要です。
以下の切断離散分布

```
y ~ poisson(3.7) T[2, 10];
```

は、以下のコードと同じ動作となります。

```
y ~ poisson(3.7);
if (y < 2 || y > 10)
  target += negative_infinity();
else
  target += -log_sum_exp(poisson_lpmf(2 | 3.7),
                         log_diff_exp(poisson_lcdf(10 | 3.7),
                                      poisson_lcdf(2 | 3.7)));
```

`log_sum_exp(a, b)`は、`log(exp(a) + exp(b)`を単に算術的に安定な形にしたものであることを思い出してください。

##### Stanにおける下限での切断

下限だけで切断するには、上限を空白のままにします。

```
y ~ normal(0, 1) T[-0.5, ];
```

切断されたサンプリング文は以下のコードと同じ動作です。

```
y ~ normal(0, 1);
  if (y < -0.5)
    target += negative_infinity();
  else
    target += -normal_lccdf(-0.5 | 0, 1);
```

`normal_lccdf`関数は正規相補累積分布関数です。

上下限の切断がある場合と同じく、離散の場合には、下限の確率質量を足し戻すために分母がより複雑になります。

```
y ~ poisson(3.7) T[2, ];
```

は、以下と同じ動作です。

```
y ~ poisson(3.7);
if (y < 2)
  target += negative_infinity();
else
  target += -log_sum_exp(poisson_lpmf(2 | 3.7),
                         poisson_lccdf(2 | 3.7));
```

##### Stanにおける上限での切断

上限だけで切断するには、下限を空白のままにします。
上限で切断されるサンプリング文

```
y ~ normal(0, 1) T[ , 2.1];
```

は以下のコードと同じ結果を生成します。

```
target += normal_lpdf(y | 0, 1);
if (y > 2.1)
  target += negative_infinity();
else
  target += -normal_lcdf(2.1 | 0, 1);
```

上限だけがあるときには、離散の場合も境界の補正は必要ありません。
上限で切断されるサンプリング文

```
y ~ poisson(3.7) T[ , 10];
```

は以下のコードと同じ挙動となります。

```
y ~ poisson(3.7);
if (y > 10)
  target += negative_infinity();
else
  target += -poisson_lcdf(10 | 3.7);
```

##### 定義する必要のある累積分布

どんな場合でも、適切な対数密度関数あるいは対数質量関数と必要な対数累積分布関数が定義されているときにだけ切断は整形式になります。
Stanに組込みのすべての分布で対数cdfおよび対数ccdfが定義されているわけではありませんし、ユーザー定義関数ではまったく定義されていないでしょう。
第3部および第4部では、利用可能な離散および連続の累積分布関数を記述しています。ほとんどの1変量分布には対数cdf関数および対数ccdf関数があります。

##### 上下限の型の制約

連続分布では、切断点は`int`型か`real`型の式でなくてはなりません。離散分布では、切断点は`int`型の式でなくてはなりません。

##### 切断の上下限外の変量

切断サンプリング文では、サンプリングされた値が切断の式で指定された上下限内にない場合には、結果は確率0となり、文全体では合計対数確率に$-\infty$を加えます。これは次にサンプルが却下される結果となります。すべての値を上下限内に保つプログラミング戦略のための、制約と、範囲外の返り値に関する議論については12.2節中の小節を参照してください。

##### 切断分布のベクトル化

Stanは、切断のある分布関数のベクトル化を（まだ）サポートしていません。

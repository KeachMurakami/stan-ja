## 6. プログラムブロック

Stanプログラムは名前をつけられた一連ブロックに沿って構成され，ブロックの中には変数の宣言が含まれており，いくつかのブロックはそのあとに文を含みます。

### 6.1 Stanのプログラムブロックの概略

名前をつけられたプログラムブロックのフルセットの例は，次のような骨格を持ったStanプログラムです。

```
functions{
	//... 関数の宣言と定義
}
data{
	//... 宣言
}
tramsformed data{
	//... 宣言 ... 文 ...
}
parameters{
	//... 宣言
}
transformed parameters{
	//... 宣言 ... 文 ...
}
model{
	//... 宣言 ... 文 ...
}
generated quantities{
	//... 宣言 ... 文 ...
}
```

関数定義ブロック(functionブロック)は，ユーザーが定義した関数を含みます。dataブロックはモデルが必要とするデータを宣言します。transformed dataブロックは定数の定義やデータの変換をするところです。parametersブロックはモデルのパラメータを宣言します。制約されていないパラメータはサンプリングされる，あるいは最適化される目的となるものです。transformed parametersブロックはこの後で使われるデータやパラメータから定義される変数を書くところで，この変数は保存されます。modelブロックは対数確率関数が定義されるところです。generated quantitiesブロックはパラメータ，データ，任意の(擬似)乱数生成などに基づいて導出された量を作るところです。

### 選択と順序

全てのブロックは取捨選択できます。これが意味するのは，Stanコンパイラが警告が発せられるようなことがあったとしても，空の文字列でも構わないということです。Stanのプログラムブロックは上で示したプログラムの骨格で示された順番に置かなければなりません。各ブロックの中では，宣言や文は選択性ですが，宣言が文の前に来なければならないという制約はあります。

### 変数のスコープ

各ブロックで宣言された変数は，それ以降全ての文に対してスコープを持ちます^[訳注；スコープとは「見える範囲」という意味で，変数名や関数名が参照できる範囲のことです。]。つまり，transformed dataブロックで宣言されあ変数はmodelブロックで使うことができます。でも，generated quantitiesブロックで宣言された変数はそれより前のどのブロックでも使うことができません。もちろんmodelブロックでも。このルールの例外は，モデルブロックで宣言される変数で，modelブロックでの変数は常にmodelブロックローカルであり，generated quantitiesブロックでもアクセスすることができません。すなわちmodelとgenerated quantitiesブロックでの変数にアクセスできるようにしようと思うなら，transformed parameterブロックで宣言しなければなりません。

関数のパラメータとして宣言された変数のスコープは，関数定義のボディの中だけで有効で，（定数を）割り当てることはできません。

### 関数のスコープ

functionブロックで定義された関数は，任意のブロックで利用できます。ほとんどの関数はどのブロックでも使用でき，パラメータやデータを混ぜるのにつかたりできます（定数やリテラルを含むこともできます）。

乱数を生成する関数は，generated quantitiesブロックに限定されます。そのような関数は後ろに`_rng`をつけます。**Log-probability modifying functions toblocks where the log probability accumulator is in scope (transformed parametersand model);**　そのような関数は後ろに`_lp`をつけます。

プログラムの中で宣言される密度関数は，サンプリング文で使えます。

### 自動変数宣言

`data`と`parameters`ブロックで宣言された変数は，使われる文脈に応じて自動的に定義された変数と比べると，扱いが異なります。これが，なぜdataブロックやparametersブロックで宣言しない変数が許されないかの理由です。

`data`ブロックにおける変数は，外部の入力ソース，例えばファイルや指定されたRのデータ構造を持ったものから読み込まれるものです。`parameters`ブロックの変数はサンプラーが現在のパラメータ値(標準のHMCやNUTSにおけるもの)から読み込まれるものです。初期値は外部の入力ソースから与えらえることもあり，その場合は普通ファイルや指定されたRのデータ構造を持っています。いずれの場合でも，パラメータはモデルが定義する対数確率関数に沿って具体的な値へと具現化されます。

### 変数変換

`transformed data`と`transformed parameters`ブロックは，いずれも同じような振る舞いをします。いずれも新しい変数を宣言でき，さらに一連の文を通じて定義されます。変数のスコープはそのあとのどの文にも及びますので，データ変換された変数はデータ変数で定義されます。

サンプルを生成する前に，データ変数は読み込まれ，それから変換されたデータ変数が宣言され，それを定義する文とともに構成されます。これが意味するのは，transformed dataブロックにおける文は一回だけしか評価されないということです^[もしC++のコードが同じスレッドで構成されていたら，dataとtransformed dataブロックは一回実行されてから，複数のチェインで再利用されます。]。transformed parametersも同じような動きをし，パラメータの項で定義されます。data変数とtransformed data変数のように。この違いは評価の頻度です。パラメータは読み込まれ，本来のスケールに基づいて対数確率と勾配の評価があるたびに，(逆に)変換されて制約された形に表現し直されます。これが意味するのは，逆変換やその**対数絶対ヤコビアン行列式log absolute Jacobian determinants**はリープフロッグステップ一回ごとに評価されるということです。それから変換されたパラメータは宣言され，一回のリープフロッグステップごとにそれを定義する文が実行されます。

### 生成量

生成量変数は，全てのリープフロッグステップが終わった後で，一回のサンプルごとに定義されます。これらは確率量かもしれないので，ブロックはHMCやNUTSのメトロポリス最適化がアップデートした提案をリジェクトした時でも再実行しなければなりません。

### 変数の読み書き，定義の要約

変数を読んだり書いたりするときの要点と定義を示した表を図6.1に示しました。変数を見るときの一つのやり方は，その関数の項を見ることです。どの変数を使おうか決めるには，図6.2のチャートを参考にしてください。最終行は該当する場所がありませんが，それはパラメータに依存しない変数を各iterationで表示する必要がないからです。この章の残りは，変数や文が各ブロックでいつ，どのように実行するかの詳細を完全に記載します。


![図6.1](fig/tbl6_1.png)

図6.1: 最後の列に書いてあるread,　write transform そして評価と**predicities**は，最初の列にあるStanプログラムブロックと対応しています。真ん中の列が示すのは，そのブロックが文を許すかどうかです。最後の行が示すのは，パラメータの初期化がread, transformの操作が各チェインについて必要であることを表しています。

![図6.2](fig/tbl6_2.png)


## 6.2 統計的変数分類法

(Gelman and Hill, 2007, p.366)は，ベイジアンモデリングで用いられている変数の分類法を提案しています。図6.3には，欠損データも含めてGelman and Hillの変数分類に沿って，Stanで宣言したり定義したりする場所を示しています。

定数はリテラル，データ変数，あるいは変数変換後の変数としてモデルに組み込むことができます。

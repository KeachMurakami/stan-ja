## Stanプログラムの実行

この章は，コンパイルされたStanモデルがどのようにサンプリングを行いながら実行されるかについて解説します。最適化でも同じデータを読み，初期化を行うステップがありますが，その先はサンプリングとは別になります。

ここの概略では，このパートの以下の章でより詳細にカバーされている，変数宣言，式，文もしくはブロックなどについて述べています。

### 8.1. 変数の読み込みと変換

データを読み込んだり変換したりするステップは，サンプリング，最適化，診断において同じものです。

#### データを読み込む

実行の最初のステップは，データをメモリに読み込む段階です。データはファイルを通じて読み込まれたり(CmdStanにおいて)，メモリを通じて読み込まれたり(RStanやPyStan)します。詳しくはそれぞれのマニュアルを参照してください^[Stanの背後で動いているC++は，データをメモリからでもファイルからでも読むことができます。例えばRから呼び出すとき，データをファイルから読むことも，Rのメモリから直接読むようにすることもできます。]。`data`ブロックで宣言される変数は全て読み込まれます。もし変数が読み込めなければ，プログラムはデータ変数がないことを示すメッセージとともに停止します。

各変数が読み込まれたあと，もしそれに制約がついていれば，その定数は評価されます。例えば変数$N$が`int<lower=0>`で宣言されていれば，$N$を読み込んだ後，それが0以上であることを満たしているかどうか検証されます。もし変数が宣言された制約の要件を満たしていなければ，プログラムは変数が不正な値を持つこと、読み込まれたその変数、宣言された制約を表示する警告メッセージを出してプログラムは停止します。

#### 変数変換(`transformed data`)の定義

データがモデルに読み込まれた後，変換されたデータ変数の定義に沿って，変換するデータ変数の文が実行されます。文が実行されるとき，変数につけられた制約は実行されません。

変換されたデータ変数が実数で初期化されるときは，`NaN`を初期値とし，整数の場合は最小の整数値(大きな絶対値をもつ負の数)を初期値とします。

文が実行された後，変換されたデータ変数につけられた制約が評価されます。もしこの妥当性チェックに失敗すれば，実行は停止，変数の名前と値と制約が表示されます。

### 8.2 初期化

初期化はサンプリング，最適化，診断において同じものです。

#### ユーザが初期値を与えるとき

ユーザがパラメータの初期値を提供する場合は，データの読み込みとおなじ入力メカニズム，同じファイルフォーマットをつかって読み込まれます。パラメータに対して宣言されるあらゆる制約は，初期値に対しても評価されます。もし変数の値がこの宣言された制約を違反しているようで荒れば，プログラムは中断して診断メッセージが表示されます。

読み込んだ後，初期値はサンプラーを初期化するのに使われる制約のない値に変換されます。

##### 境界の値は問題あり

Stanは制約されたものを制約されていない空間に変換するやり方を取っているので，制約の境界付近でパラメータの初期値を与えることは問題を生じやすくします。例えば次のような制約があるとします。

```
parameters {
  real<lower=0,upper=1> theta;
  //..
}
```

ここで$theta$の初期値を$0$にすると，制約されていない値としては$-¥infty$になり，一方値を$1$にすると制約されていない値としては$¥infty$になります。これは不動点の計算があれば正しく逆変換できますが，ヤコビアンが無限大になり対数尤度関数は失敗，例外を生じさせます。

#### ランダムな初期値

ユーザーから初期値が与えられなければ，デフォルトの初期化戦略は区間$(-2,2)$の一様分布から直接取ってきた値を，制限されていないパラメータに初期値として与えるというものです。この初期化の境界は変えることができますが，$0$を中心に左右対称になります。値$0$は初期値の中央値を表すものとして特別なものです。制限されていない値$0$は，パラメータ宣言の制約に合わせて異なるパラメータ値になります。

制限されていない実数はいかなる変換も含まないので，制限されてないパラメータに対する初期値$0$は制限されたパラメータに対する$0$でもあります。

下限$0$のパラメータについては，制限されていないスケールに対する初期値の$0$は，制限されたスケールにおける$exp(0)=1$に対応します。$-2$という値は，$exp(-2)=0.13$に対応しますし，$2$という値は$exp(2)=7.4$に対応します。

上限，下限の境界を持つパラメータに対しては，制限されていないスケールに対する初期値の$0$は，制限された区間の中点の値に対応します。確率的パラメータに対しては，境界は下に$0$で上に$1$ですが，これを逆ロジット変換することで，初期値である制限されていない値$0$が制限された値$0.5$に対応しますし，$-2$は$0.12$に，$2$は$0.88$に対応します。$0$と$1$以外の境界についてもスケールの調整と変換が行われます。

制限されていない基底における初期値$0$をもつシンプレックス変数は，制限された値における対称な値に対応します(すなわち，$K$-simplexは$1/K$の値を持ちます)。

正定値行列に対するコレスキー因子は，対角が$1$でそれ以外が$0$になるように初期化されます。なぜなら，対角は対数変換され，対角の下の値は制限されない値だからあです。

他のパラメータに対する初期値は適用される変換から決定されます。この変換については，34章で完全に解説sれます。

#### 初期値0

制限されていない尺度については初期値は全て$0$にセットされます。これは診断には有益で，サンプリングにおける出発点としても良いものです。一度モデルが走り始めれば，複数のチェインがより拡散したスタート地点から始まったほうが，収束問題を診断するのには有益でしょう。収束のモニタリングについての更なる情報はセクション29.3を参照して下さい。

### 8.3 サンプリング

サンプリングは，現在のパラメータ値とランダムに生成された初期の運動量(運動エネルギー)に等しいスタート地点で，微小なハミルトニアンをシミュレートすることに基づいています。微小量における位置エネルギーについて，モデルによって定義された(正規化されていない)確率関数全体の負の対数を取ります。HMCを実装するふつうのやり方では，微小量に対するハミルトニアン・ダイナミクスはリープフロッグ積分を使うことでシミュレートされ，微小量の滑らかなパスを離散化し，リープフロッグステップとよばれる小さな時間ステップ数の中に入れられます。

#### リープフロッグステップ

リープフロッグステップごとに，現在のパラメータ値に対応する位置エネルギーに必要な負の対数確率関数と勾配が評価されます(より詳しいスケッチは次のセクションで説明します)。勾配に基いて運動量がアップデートされ，運動量に基いて位置がアップデートされる，というように使われます。

シンプルなモデルであれば，大きなステップサイズと数回のリープフロッグステップが必要です。複雑な事後分布の形状であれば，多くの小さなリープフロッグステップが，パラメータの通り道を正確にモデル化するのに必要になります。

もしユーザーがリープフロッグステップの数を指定すれば(標準的なHMCを使う事を選べば)，その数だけリープフロッグステップがシミュレートされます。もしユーザーが特にリープフロッグステップ数を指定しなければ，No-U-Turnサンプラー(NUTS)が適切なリープフロッグステップ数を決めます(Hoffman and Gelman,2011,2014).

#### 対数確率と勾配の計算

それぞれのリープフロッグステップの間，対数確率関数と勾配を計算しなければなりません。これがStanアルゴリズムが最も時間を費やす個所です。この対数確率関数は，サンプリングアルゴリズムでも使われますが，制限されていないパラメータ全体に対して定義されます。

計算の最初の段階で必要なのは，制限されていないパラメータ値を逆変換して，モデルの中で定義されているような制限されたパラメータにする事です。ここではエラーチェックが求められません。と言うのも，逆変換は全ての点において制限の範囲を満たすように，全体的な関数で行うからです。

モデルの中で記述される確率の文は制限されたパラメータの項を使って定義されていますから，逆変換はの対数ヤコビアンが累積対数確率に加算されます。

次に，`transformed parameters`の文が実行されます。それがすべて終わってから，`transformed parameters`で宣言された制限がチェックされます。もし制限が破られていたら，モデルは診断メッセージと共に中断されます。

対数確率計算の最後のステップは，モデルブロックにおける文を実行する事です。

対数確率関数が実行される際は，対数確率の計算にはメモリ内にある式ツリーの表現が累算されます。これには全てのパラメータ変換経産が含まれ，また全てのヤコビアン調整が含まれます。このツリーは，裏にある式のグラフにそって伝播する偏導関数によって，勾配を評価するのに使われます。勾配の計算はStanプログラムによって消費されるサイクルのほとんどの部分を占めています。

#### メトロポリスの採択／棄却

標準的なメトロポリスの採択/棄却ステップは，細部のバランスを保つ事とモデルによって定義された確率関数にしたがう周辺分布全体からサンプルできていることを必要とします。メトロポリスの最適化は対数確率の比較が基本で，ここではハミルトニアンによって定義されていますが，これは位置エネルギー(負の対数確率)と運動エネルギー(運動量の二乗)を足し合わせたものです。理論的には，ハミルトニアンは微小量のパス上では普遍で，棄却は生じません。実際に，棄却の確率はパラメータの真の軌跡に対するリープフロッグの近似の正確さによって決定されます。

ステップサイズが小さければ，ごくわずかのアップデートが棄却されるだけですが，同じ距離を移動するにも多くのステップを必要とします。ステップサイズが大きければ，より多くの棄却が生じ得ますが，同じ距離を移動するのにより少ないステップで済みます。ですから，エフォートと棄却のバランスが必要なのです。もしユーザーが特にステップサイズを指定しなければ，Stanはウォームアップサンプリング中にステップサイズを調整し，望ましい棄却率(つまりステップ数に対する棄却のバランス)になるようにします。

もし提案が採択されれば，パラメータは新しい値にアップデートされます。そうでなければ，パラメータの値は現在の設定のままになります。

### 8.4 最適化

最適化はデータを読み込んだ時からパラメータの初期化まで，サンプリングのときと同じ様にふるまいます。サンプリングの時とは違って，最適化関数自体が事後最頻値に収束したかどうかを検証する以上の分析を必要としない決定論的な出力を算出します。最適化の出力も，サンプリングによるものと似ています。

### 8.5 変分推定

変分近似もサンプリングと似たふるまいをします。これはデータの読み込みと初期化のアルゴリズムから始まります。初期の変分近似は，制限されていない(実数次元の)空間からの，標準正規分布からのランダムなドローです。それからサンプリングと同じように，一度収束したとアルゴリズムが判断した，事後分布の近似からサンプルを取りだします。つまり，このStanのサンプリングルーチンの結果を分析するのにつかうこのツールは，変分推定としても使えるのです。

### 8.6 モデル診断

モデル診断は，モデルがデータを読み込み，そのパラメータが初期化されるのに依存しているので，サンプリングと最適化で似ています。インターフェイス(RStan,PyStanCmdStan)のユーザーガイドでは，可能な診断についてより詳しく書いてあります。Stan2.0では，制限されていないスケールと対数確率についての勾配だけに行われます。


### 8.7 出力

それぞれ最終サンプル(ウォームアップ中のサンプルや間引かれたサンプルは数えません)になれば，サンプルの結果を書き出す段階になります。

#### 生成量

出力する前に，`generated quantities`ブロックの文が実行されます。これはモデルのパラメータに基づく，さらなるシミュレーションとして用いることができます。あるいは，結果から適当なパラメータに変換するのに使われます。

生成量の文が実行された後，生成量変数として宣言されたときの制限が妥当であったか評価されます。もしここでの制限が破られていたら，プログラムは診断メッセージとともに中断します。

#### 書き出し

最後のステップは実際の値を書き出すことです。パラメータ，変換されたパラメータ，生成量として宣言された全ての変数の値が書き出されます。ローカル変数は書き出されませんし，データや変換されたデータも書き出されることはありません。全ての値はその制限された形，モデルの定義で使われていた形式になっています。

Stanモデルの実行形式の中では，パラメータ，変換されたパラメータ，生成量は，パラメータの名前を持ったヘッダーをつけた，コンマ区切り形式のファイル(csv)で書き出されます(多変量パラメータのインデックスも含みます)^[StanのRバージョンでは，値はcsvファイルに書き込まれるか，直接Rのメモリに書き込まれます。]。

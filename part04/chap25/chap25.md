## 25. コンテナ(値の入れ物): 配列, `vector`, and `matrix`
Stanには配列, `vector`, `matrix` 3つのコンテナの型が用意されています。これら3つの型は取り換え可能ではありません。たとえ次元が一致していても、ある型の変数から別の型の変数に代入できません。Stanにおいて、3 × 4の`matrix`は3 × 4の配列とは全く別種類のオブジェクトなのです。

### 25.1. `vector` and `matrix`
`vector`, `matrix`は配列に比べると、制限されたデータ構造になっています。`vector`は本来`real`を1次元状に集めたもので、`matrix`は本来2次元状に集めたものです。

`matrix`型の用途は、コード内で行列を使用していることを強調するためです。Stanにおいて、`vector`,` matrix`型を使うのはおそらく以下の3つの場合のみでしょう。

1. 行列演算 (行列の乗算など)
2. 線形代数の関数 (固有値, 行列式など)
3. 多変量関数のパラメータと出力 (多変量正規分布の引数など)

`vector`, `matrix`は整数値を返すことはできず、取り扱えるのは`real`に限られています。(注1)

(注1):Stanにおいて、複雑な整数行列演算や、ブール行列演算が実行されている際にはこれは変更される場合があります。これは、整数が行列演算に適切な入力ではないためです。

### 25.2. 配列
他方、配列は、は本来、他の種類のオブジェクトを1次元状に集めたものです。配列には単純な`real`や`int`, `vector`, `matrix`、別の配列のような、あらゆるデータ型の値を格納することができます。配列はStanにおいて唯一、整数値の並びを格納できる型です。Stanにおいては、離散分布などの関数が整数値を引数とします。
2次元の配列は概念的にも現在の実装面からも、配列を並べたものとして扱うことができます。インデックスを配列に与えると、配列はそのインデックスにおける値を返します。複数のインデックスを配列に与えると、連鎖的にインデックスにおける値を返す動作が行われます。例えば、`a`という2次元配列があったとすると、`a[m,n]`という書き方は`a[m][n]`の便利な縮めた書き方にすぎません。

### 25.3. 効率についての考察
Stanの根底にある設計の動機の1つとして計算の効率があります。

Stanにおいて、行列、線形代数の演算はEigen C++ライブラリのデータ型をベースに実装されています。このため、行列演算や線形代数の関数を使用する際`vector`, `matrix`を型としていれば、データ型を変換する必要はありません。
他方、配列はC++の`std::vector`クラスのインスタンスとして実装されています。(Eigenライブラリの`Eigen::vector`クラスや、 Stanの`vector`と混同しないように注意しましょう)。配列はこのように実装されているため、インデックスにおける値を返すのはとても効率的です。なぜならコピーして値を返すのではなく参照を使って値を返すからです。

#### `matrix` vs. 2次元配列
Stanのモデルにおいて、2次元配列と`matrix`のどちらを使うか決めるときに、効率について2,3個考えることがあります。一見、2次元配列と`matrix`のどちらを使ってもよく思われるかもしれません。
第1に、`matrix`は2次元配列よりもメモリの使用量が少ない点です。これは、`matrix`では、配列の並び方は保存せず、データと2つの次元の情報だけを保存しているためです。

第2に、`matrix`は「列優先」の順序でデータを格納する点です。さらに、`matrix`内のすべてのデータはメモリ内で隣接することが保証されます。これは最適化されたコードを考えると大切なことです。なぜなら現代のCPUを使った算術演算を実行することよりもデータをメモリからキャッシュに持っていくことの方がはるかに時間がかかるからです。
他方、配列はプリミティブ型の値はメモリ内で隣接することを保証しており、それ以外の場合はその値のコピーを保持します（可能な限り、参照を使って値を返します）。

第3に、いずれのデータ構造もデータが保持されている順序でインデックスを移動させると最も速くアクセスできます。メモリ上の位置もアクセス速度に関係します。`matrix`は列優先であるため、以下の順序でインデックスを移動させるのが適切です。

```
  matrix[M,N] a;
  //...
  for (n in 1:N)  //列が先
    for (m in 1:M)  //行が後
      // ... a[m,n]を使った計算...
```

他方、配列は以下の例のように行優先の順序でインデックスを移動させるべきです（すなわち、最後のインデックスが最も移動するのが速い）。

```
  real a[M,N];
  // ...
  for (m in 1:M)  //行が先
    for (n in 1:N)  //列が後
      // ... a[m,n]を使った計算...
```

最初に`a[m,n]`を使う際には、`a[m]`をメモリに持ってくるように書くべきです。一般的に、`matrix`内の移動は、配列内の移動よりも効率が良いです。
これは`matrix`の配列についても同様です。例えば、`matrix`の2次元配列のインデックスを移動してアクセスするのに理想的な順序は以下になります。

```
  matrix[M,N] b[I,J];
  // ...
  for (i in 1:I)  //配列なので行が先
    for (j in 1:J)  //配列なので列が後
      for (n in 1:N)  //matrixなので列が先
        for (m in 1:M) //matrixなので行が後
          //... b[i,j,m,n] を使った計算...
```

`a`が`matrix`の場合、`a[m]`と表記するとその`matrix`の行`m`が抽出されますが、これは`matrix`を取り扱う上では非効率な操作です。もし複数の`vector`にインデックスでアクセスする必要があるならば、`vector`の配列を宣言する方がはるかに良いです。

```
  row_vector[N] b[M];
  // ...
  for (m in 1:M)
    //... row vector b[m]を使った計算 ...
```

これは以下の`matrix`を使った例よりも圧倒的に効率的です。

```
  matrix b[M,N];
  // ...
  for (m in 1:M)
    // ... row vector b[m]を使った計算  ...
```

同様に、列ベクトルの配列に対してインデックスを移動させてアクセスする方が、`matrix`の列を抽出する`col`関数を使うよりも効率的です。対照的に、行列演算や線形代数の関数として行われることは何でも`matrix`が一番速いでしょう。だから、もし予測変数と係数のドット積（訳注: 要素ごとにかけて和をとったもの, 内積）の行を作成したい場合には、以下のように記述することで、

```
  matrix[N,K] x; // 予測変数（説明変数, 共変量としても知られる）
  // ...
  vector[K] beta; // 係数
  // ...
  vector[N] y_hat; // 線形予測
  // ...
  y_hat <- x * beta;
```

  以下のように書くよりも効率よく列を作ることができます。

```
  row_vector[K] x[N]; // predictors (aka covariates)
  // ...
  vector[K] beta; // coeffs
  ...
  vector[N] y_hat; // linear prediction
  ...
  for (n in 1:N)
    y_hat[n] <- x[n] * beta;
```

#### （列）`vector` vs. 1次元配列
列ベクトル`vector`と行ベクトル`row_vector`と1次元配列の間にはまったく違いがありません。。`Eigen:vector`テンプレートと、`C++`の`std:vector`テンプレートクラスは、`double`型の値のコンテナとして非常に近い形で実装されています (Stanでは`real`型)。ただし、Stanにおいて整数値を格納できるのは配列だけです。
